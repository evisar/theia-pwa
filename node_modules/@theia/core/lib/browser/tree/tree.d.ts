/********************************************************************************
 * Copyright (C) 2017 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
import { Event, Emitter, Disposable, DisposableCollection } from '../../common';
export declare const Tree: unique symbol;
/**
 * The tree - an abstract data type.
 */
export interface Tree extends Disposable {
    /**
     * A root node of this tree.
     * Undefined if there is no root node.
     * Setting a root node refreshes the tree.
     */
    root: TreeNode | undefined;
    /**
     * Emit when the tree is changed.
     */
    readonly onChanged: Event<void>;
    /**
     * Return a node for the given identifier or undefined if such does not exist.
     */
    getNode(id: string | undefined): TreeNode | undefined;
    /**
     * Return a valid node in this tree matching to the given; otherwise undefined.
     */
    validateNode(node: TreeNode | undefined): TreeNode | undefined;
    /**
     * Refresh children of the root node.
     */
    refresh(): Promise<void>;
    /**
     * Refresh children of the given node if it is valid.
     */
    refresh(parent: Readonly<CompositeTreeNode>): Promise<void>;
    /**
     * Emit when the children of the given node are refreshed.
     */
    readonly onNodeRefreshed: Event<Readonly<CompositeTreeNode>>;
}
/**
 * The tree node.
 */
export interface TreeNode {
    /**
     * An unique id of this node.
     */
    readonly id: string;
    /**
     * A human-readable name of this tree node.
     */
    readonly name: string;
    /**
     * A css string for this tree node icon.
     */
    readonly icon?: string;
    /**
     * A human-readable description of this tree node.
     */
    readonly description?: string;
    /**
     * Test whether this node should be rendered.
     * If undefined then node will be rendered.
     */
    readonly visible?: boolean;
    /**
     * A parent node of this tree node.
     * Undefined if this node is root.
     */
    readonly parent: Readonly<CompositeTreeNode> | undefined;
    /**
     * A previous sibling of this tree node.
     */
    readonly previousSibling?: TreeNode;
    /**
     * A next sibling of this tree node.
     */
    readonly nextSibling?: TreeNode;
}
export declare namespace TreeNode {
    function equals(left: TreeNode | undefined, right: TreeNode | undefined): boolean;
    function isVisible(node: TreeNode | undefined): boolean;
}
/**
 * The composite tree node.
 */
export interface CompositeTreeNode extends TreeNode {
    /**
     * Child nodes of this tree node.
     */
    children: ReadonlyArray<TreeNode>;
}
export declare namespace CompositeTreeNode {
    function is(node: TreeNode | undefined): node is CompositeTreeNode;
    function getFirstChild(parent: CompositeTreeNode): TreeNode | undefined;
    function getLastChild(parent: CompositeTreeNode): TreeNode | undefined;
    function isAncestor(parent: CompositeTreeNode, child: TreeNode | undefined): boolean;
    function indexOf(parent: CompositeTreeNode, node: TreeNode | undefined): number;
    function addChildren(parent: CompositeTreeNode, children: TreeNode[]): CompositeTreeNode;
    function addChild(parent: CompositeTreeNode, child: TreeNode): CompositeTreeNode;
    function removeChild(parent: CompositeTreeNode, child: TreeNode): void;
    function setParent(child: TreeNode, index: number, parent: CompositeTreeNode): void;
}
/**
 * A default implementation of the tree.
 */
export declare class TreeImpl implements Tree {
    protected _root: TreeNode | undefined;
    protected readonly onChangedEmitter: Emitter<void>;
    protected readonly onNodeRefreshedEmitter: Emitter<CompositeTreeNode>;
    protected readonly toDispose: DisposableCollection;
    protected nodes: {
        [id: string]: TreeNode | undefined;
    };
    constructor();
    dispose(): void;
    root: TreeNode | undefined;
    readonly onChanged: Event<void>;
    protected fireChanged(): void;
    readonly onNodeRefreshed: Event<CompositeTreeNode>;
    protected fireNodeRefreshed(parent: CompositeTreeNode): void;
    getNode(id: string | undefined): TreeNode | undefined;
    validateNode(node: TreeNode | undefined): TreeNode | undefined;
    refresh(raw?: CompositeTreeNode): Promise<void>;
    protected resolveChildren(parent: CompositeTreeNode): Promise<TreeNode[]>;
    protected setChildren(parent: CompositeTreeNode, children: TreeNode[]): void;
    protected removeNode(node: TreeNode | undefined): void;
    protected getRootNode(node: TreeNode): TreeNode;
    protected addNode(node: TreeNode | undefined): void;
}
//# sourceMappingURL=tree.d.ts.map