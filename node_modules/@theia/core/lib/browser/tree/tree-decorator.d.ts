/********************************************************************************
 * Copyright (C) 2018 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
import { Tree } from './tree';
import { Event, Emitter, Disposable, DisposableCollection, MaybePromise } from '../../common';
/**
 * Tree decorator that can change the look and the style of the tree items within a widget.
 */
export interface TreeDecorator {
    /**
     * The unique identifier of the decorator. Ought to be unique in the application.
     */
    readonly id: string;
    /**
     * Fired when this decorator has calculated all the decoration data for the tree nodes. Keys are the unique identifier of the tree nodes.
     */
    readonly onDidChangeDecorations: Event<(tree: Tree) => Map<string, TreeDecoration.Data>>;
    /**
     * Returns with the current decoration data for the tree argument.
     *
     * @param tree the tree to decorate.
     */
    decorations(tree: Tree): MaybePromise<Map<string, TreeDecoration.Data>>;
}
/**
 * Decorator service which emits events from all known tree decorators.
 * Keys are the unique tree node IDs and the values
 * are the decoration data collected from all the decorators known by this service.
 */
export declare const TreeDecoratorService: unique symbol;
export interface TreeDecoratorService extends Disposable {
    /**
     * Fired when any of the available tree decorators has changes.
     */
    readonly onDidChangeDecorations: Event<void>;
    /**
     * Returns with the decorators for the tree based on the actual state of this decorator service.
     */
    getDecorations(tree: Tree): MaybePromise<Map<string, TreeDecoration.Data[]>>;
    /**
     * Transforms the decorators argument into an object, so that it can be safely serialized into JSON.
     */
    deflateDecorators(decorations: Map<string, TreeDecoration.Data[]>): object;
    /**
     * Counterpart of the [deflateDecorators](#deflateDecorators) method. Restores the argument into a Map
     * of tree node IDs and the corresponding decorations data array.
     */
    inflateDecorators(state: any): Map<string, TreeDecoration.Data[]>;
}
/**
 * The default tree decorator service. Does nothing at all. One has to rebind to a concrete implementation
 * if decorators have to be supported in the tree widget.
 */
export declare class NoopTreeDecoratorService implements TreeDecoratorService {
    protected readonly emitter: Emitter<void>;
    readonly onDidChangeDecorations: Event<void>;
    dispose(): void;
    getDecorations(): Map<any, any>;
    deflateDecorators(): object;
    inflateDecorators(): Map<string, TreeDecoration.Data[]>;
}
/**
 * Abstract decorator service implementation which emits events from all known tree decorators and caches the current state.
 */
export declare abstract class AbstractTreeDecoratorService implements TreeDecoratorService {
    protected readonly decorators: ReadonlyArray<TreeDecorator>;
    protected readonly onDidChangeDecorationsEmitter: Emitter<void>;
    readonly onDidChangeDecorations: Event<void>;
    protected readonly toDispose: DisposableCollection;
    constructor(decorators: ReadonlyArray<TreeDecorator>);
    dispose(): void;
    getDecorations(tree: Tree): Promise<Map<string, TreeDecoration.Data[]>>;
    deflateDecorators(decorations: Map<string, TreeDecoration.Data[]>): object;
    inflateDecorators(state: any): Map<string, TreeDecoration.Data[]>;
}
/**
 * Namespace for the decoration data and the styling refinements for the decorated tree nodes.
 */
export declare namespace TreeDecoration {
    /**
     * CSS styles for the tree decorators.
     */
    namespace Styles {
        const CAPTION_HIGHLIGHT_CLASS = "theia-caption-highlight";
        const CAPTION_PREFIX_CLASS = "theia-caption-prefix";
        const CAPTION_SUFFIX_CLASS = "theia-caption-suffix";
        const ICON_WRAPPER_CLASS = "theia-icon-wrapper";
        const DECORATOR_SIZE_CLASS = "theia-decorator-size";
        const TOP_RIGHT_CLASS = "theia-top-right";
        const BOTTOM_RIGHT_CLASS = "theia-bottom-right";
        const BOTTOM_LEFT_CLASS = "theia-bottom-left";
        const TOP_LEFT_CLASS = "theia-top-left";
    }
    /**
     * For the sake of simplicity, we have merged the `font-style`, `font-weight`, and the `text-decoration` together.
     */
    type FontStyle = 'normal' | 'bold' | 'italic' | 'oblique' | 'underline' | 'line-through';
    /**
     * A string that could be:
     *
     *  - one of the browser colors, (E.g.: `blue`, `red`, `magenta`),
     *  - the case insensitive hexadecimal color code, (for instance, `#ee82ee`, `#20B2AA`, `#f09` ), or
     *  - either the `rgb()` or the `rgba()` functions.
     *
     * For more details, see: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value.
     *
     * Note, it is highly recommended to use one of the predefined colors of Theia, so the desired color will
     * look nice with both the `light` and the `dark` theme too.
     */
    type Color = string;
    /**
     * Encapsulates styling information of the font.
     */
    interface FontData {
        /**
         * Zero to any font style.
         */
        readonly style?: FontStyle | FontStyle[];
        /**
         * The color of the font.
         */
        readonly color?: Color;
    }
    /**
     * Arbitrary information that has to be shown either before or after the caption as a prefix or a suffix.
     */
    interface CaptionAffix {
        /**
         * The text content of the prefix or the suffix.
         */
        readonly data: string;
        /**
         * Font data for customizing the prefix of the suffix.
         */
        readonly fontData?: FontData;
    }
    /**
     * Unlike caption suffixes, tail decorations appears right-aligned after the caption and the caption suffixes (is any).
     */
    interface TailDecoration extends CaptionAffix {
        /**
         * Optional tooltip for the tail decoration.
         */
        readonly tooltip?: string;
    }
    /**
     * Enumeration for the quadrant to overlay the image on.
     */
    enum IconOverlayPosition {
        /**
         * Overlays the top right quarter of the original image.
         */
        TOP_RIGHT = 0,
        /**
         * Overlays the bottom right of the original image.
         */
        BOTTOM_RIGHT = 1,
        /**
         * Overlays the bottom left segment of the original image.
         */
        BOTTOM_LEFT = 2,
        /**
         * Occupies the top left quarter of the original icon.
         */
        TOP_LEFT = 3
    }
    namespace IconOverlayPosition {
        /**
         * Returns with the CSS class style for the enum.
         */
        function getStyle(position: IconOverlayPosition): string;
    }
    /**
     * A shape that can be optionally rendered behind the overlay icon. Can be used to further refine colors.
     */
    interface IconOverlayBackground {
        /**
         * Either `circle` or `square`.
         */
        readonly shape: 'circle' | 'square';
        /**
         * The color of the background shape.
         */
        readonly color?: Color;
    }
    /**
     * Has not effect if the tree node being decorated has no associated icon.
     */
    interface IconOverlay {
        /**
         * The position where the decoration will be placed on the top of the original icon.
         */
        readonly position: IconOverlayPosition;
        /**
         * This should be the name of the Font Awesome icon with out the `fa fa-` prefix, just the name, for instance `paw`.
         * For the existing icons, see here: https://fontawesome.com/v4.7.0/icons/.
         */
        readonly icon: string;
        /**
         * The color of the overlaying icon. If not specified, then the default icon color will be used.
         */
        readonly color?: Color;
        /**
         * The optional background color of the overlay icon.
         */
        readonly background?: IconOverlayBackground;
    }
    /**
     * The caption highlighting with the highlighted ranges and an optional background color.
     */
    interface CaptionHighlight {
        /**
         * The ranges to highlight in the caption.
         */
        readonly ranges: CaptionHighlight.Range[];
        /**
         * The optional color of the text data that is being highlighted. Falls back to the default `mark` color values defined under a tree node segment class.
         */
        readonly color?: Color;
        /**
         * The optional background color of the text data that is being highlighted.
         */
        readonly backgroundColor?: Color;
    }
    namespace CaptionHighlight {
        /**
         * A pair of offset and length that has to be highlighted as a range.
         */
        interface Range {
            /**
             * Zero based offset of the highlighted region.
             */
            readonly offset: number;
            /**
             * The length of the highlighted region.
             */
            readonly length: number;
        }
        namespace Range {
            /**
             * `true` if the `arg` is contained in the range. The ranges are closed ranges, hence the check is inclusive.
             */
            function contains(arg: number, range: Range): boolean;
        }
        /**
         * The result of a caption splitting based on the highlighting information.
         */
        interface Fragment {
            /**
             * The text data of the fragment.
             */
            readonly data: string;
            /**
             * Has to be highlighted if defined.
             */
            readonly highligh?: true;
        }
        /**
         * Splits the `caption` argument based on the ranges from the `highlight` argument.
         */
        function split(caption: string, highlight: CaptionHighlight): Fragment[];
    }
    /**
     * Encapsulates styling information that has to be applied on the tree node which we decorate.
     */
    interface Data {
        /**
         * The higher number has higher priority. If not specified, treated as `0`.
         * When multiple decorators are available for the same item, and decoration data cannot be merged together,
         * then the higher priority item will be applied on the decorated element and the lower priority will be ignored.
         */
        readonly priority?: number;
        /**
         * The font data for the caption.
         */
        readonly fontData?: FontData;
        /**
         * The background color of the entire row.
         */
        readonly backgroundColor?: Color;
        /**
         * Optional, leading prefixes right before the caption.
         */
        readonly captionPrefixes?: CaptionAffix[];
        /**
         * Suffixes that might come after the caption as an additional information.
         */
        readonly captionSuffixes?: CaptionAffix[];
        /**
         * Optional right-aligned decorations that appear after the node caption and after the caption suffixes (is any).
         */
        readonly tailDecorations?: TailDecoration[];
        /**
         * Custom tooltip for the decorated item. Tooltip will be appended to the original tooltip, if any.
         */
        readonly tooltip?: string;
        /**
         * Sets the color of the icon. Ignored if the decorated item has no icon.
         */
        readonly iconColor?: Color;
        /**
         * Has not effect if given, but the tree node does not have an associated image.
         */
        readonly iconOverlay?: IconOverlay;
        /**
         * An array of ranges to highlight the caption.
         */
        readonly highlight?: CaptionHighlight;
    }
    namespace Data {
        /**
         * Compares the decoration data based on the priority. Lowest priorities come first.
         */
        const comparePriority: (left: Data, right: Data) => number;
    }
}
//# sourceMappingURL=tree-decorator.d.ts.map