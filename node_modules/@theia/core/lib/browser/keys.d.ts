/********************************************************************************
 * Copyright (C) 2017 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
/**
 * The key sequence for this binding. This key sequence should consist of one or more key strokes. Key strokes
 * consist of one or more keys held down at the same time. This should be zero or more modifier keys, and zero or one other key.
 * Since `M2+M3+<Key>` (Alt+Shift+<Key>) is reserved on MacOS X for writing special characters, such bindings are commonly
 * undefined for platform MacOS X and redefined as `M1+M3+<Key>`. The rule applies on the `M3+M2+<Key>` sequence.
 */
export interface Keystroke {
    readonly first?: Key;
    readonly modifiers?: KeyModifier[];
}
export declare type KeySequence = KeyCode[];
export declare namespace KeySequence {
    function equals(a: KeySequence, b: KeySequence): boolean;
    enum CompareResult {
        NONE = 0,
        PARTIAL = 1,
        SHADOW = 2,
        FULL = 3
    }
    function compare(a: KeySequence, b: KeySequence): CompareResult;
    function parse(keybinding: string): KeySequence;
    /**
     * Return an array of strings representing the keys in this keysequence.
     * For example ['ctrlcmd p', 'ctrlcmd k'].  The character used between
     * keys can be overriden using `separator`.
     */
    function acceleratorFor(keySequence: KeySequence, separator?: string): string[];
}
/**
 * Representation of a platform independent key code.
 */
export declare class KeyCode {
    readonly keystroke: string;
    readonly character?: string | undefined;
    readonly key: Key | undefined;
    readonly ctrl: boolean;
    readonly shift: boolean;
    readonly alt: boolean;
    readonly meta: boolean;
    private static keybindings;
    constructor(keystroke: string, character?: string | undefined);
    /**
     * Returns a normalized version of this keycode, if
     * - shift or alt was pressed
     * - meta or ctrl was pressed
     * - a character exists
     * - the character corresponds to a key on the US keyboard layout
     *
     * The resulting KeyCode will remove the shift/alt keys and use the character as the key.
     * For instance on a german kb layout the sequence `ctrlCmd+shift+7` would be translated to `ctrlCmd+/`.
     * @returns a normalized keycode or undefined
     */
    normalizeToUsLayout(): KeyCode | undefined;
    static isModifierString(key: string): boolean;
    /**
     * Returns true KeyCode only contains modifiers.
     */
    isModifierOnly(): boolean;
    /**
     * Parses a string and returns a KeyCode object.
     * @param keybinding String representation of a keybinding
     */
    static parse(keybinding: string): KeyCode;
    static createKeyCode(event: KeyboardEvent | Keystroke): KeyCode;
    /**
     * Determine a code that can be turned into a Key using `Key.getKey()`.
     *
     * This function should consider the actual keyboard layout as much as possible, which is not supported
     * by the `code` property of `KeyboardEvent`. Some keyboard layouts contain keys that cannot be represented
     * with such a code (e.g. the &Ouml; key on German keyboards). In these cases this function often returns
     * the key code according to the US keyboard layout; `toCharacter()` might deliver a more appropriate hint
     * on which key was actually pressed.
     *
     * `keyIdentifier` is used to access this deprecated field:
     * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyIdentifier
     */
    static toCode(event: KeyboardEvent & {
        readonly keyIdentifier?: string;
    }): string;
    /**
     * Determine the actual printable character that is generated from a pressed key.
     * If the key does not correspond to a printable character, `undefined` is returned.
     * The result may be altered by modifier keys.
     */
    static toCharacter(event: KeyboardEvent): string | undefined;
    static equals(keyCode1: KeyCode, keyCode2: KeyCode): boolean;
    equals(event: KeyboardEvent | KeyCode): boolean;
    static resetKeyBindings(): void;
    toString(): string;
}
export declare namespace KeyCode {
    /**
     * Determines a `true` of `false` value for the key code argument.
     */
    type Predicate = (keyCode: KeyCode) => boolean;
    /**
     * Different scopes have different execution environments. This means that they have different built-ins
     * (different global object, different constructors, etc.). This may result in unexpected results. For instance,
     * `[] instanceof window.frames[0].Array` will return `false`, because `Array.prototype !== window.frames[0].Array`
     * and arrays inherit from the former.
     * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof
     *
     * Note: just add another check if the current `event.type` checking is insufficient.
     */
    function isKeyboardEvent(event: object & Readonly<{
        type?: string;
    }>): event is KeyboardEvent;
}
export declare enum KeyModifier {
    /**
     * M1 is the COMMAND key on MacOS X, and the CTRL key on most other platforms.
     */
    CtrlCmd = "M1",
    /**
     * M2 is the SHIFT key.
     */
    Shift = "M2",
    /**
     * M3 is the Option key on MacOS X, and the ALT key on most other platforms.
     */
    Alt = "M3",
    /**
     * M4 is the CTRL key on MacOS X, and is undefined on other platforms.
     */
    MacCtrl = "M4"
}
export declare namespace KeyModifier {
    /**
     * The CTRL key, independently of the platform.
     * _Note:_ In general `KeyModifier.CtrlCmd` should be preferred over this constant.
     */
    const CTRL: KeyModifier.MacCtrl | KeyModifier.CtrlCmd;
    /**
     * An alias for the SHIFT key (`KeyModifier.Shift`).
     */
    const SHIFT: KeyModifier.Shift;
    /**
     * `true` if the argument represents a modifier. Otherwise, `false`.
     */
    function isModifier(key: string | undefined): boolean;
}
export interface Key {
    readonly code: string;
    readonly keyCode: number;
}
export interface EasyKey {
    readonly keyCode: number;
    readonly easyString: string;
}
export declare namespace SpecialCases {
    const META = "meta";
    const CTRLCMD = "ctrlcmd";
}
export declare namespace EasyKey {
    const ENTER: EasyKey;
    const SPACE: EasyKey;
    const BACKSPACE: EasyKey;
    const TAB: EasyKey;
    const DELETE: EasyKey;
    const END: EasyKey;
    const HOME: EasyKey;
    const INSERT: EasyKey;
    const PAGE_DOWN: EasyKey;
    const PAGE_UP: EasyKey;
    const ARROW_DOWN: EasyKey;
    const ARROW_LEFT: EasyKey;
    const ARROW_RIGHT: EasyKey;
    const ARROW_UP: EasyKey;
    const ESCAPE: EasyKey;
    const ALT: EasyKey;
    const CAPS_LOCK: EasyKey;
    const CONTROL: EasyKey;
    const OS: EasyKey;
    const SHIFT: EasyKey;
    const DIGIT1: EasyKey;
    const DIGIT2: EasyKey;
    const DIGIT3: EasyKey;
    const DIGIT4: EasyKey;
    const DIGIT5: EasyKey;
    const DIGIT6: EasyKey;
    const DIGIT7: EasyKey;
    const DIGIT8: EasyKey;
    const DIGIT9: EasyKey;
    const DIGIT0: EasyKey;
    const KEY_A: EasyKey;
    const KEY_B: EasyKey;
    const KEY_C: EasyKey;
    const KEY_D: EasyKey;
    const KEY_E: EasyKey;
    const KEY_F: EasyKey;
    const KEY_G: EasyKey;
    const KEY_H: EasyKey;
    const KEY_I: EasyKey;
    const KEY_J: EasyKey;
    const KEY_K: EasyKey;
    const KEY_L: EasyKey;
    const KEY_M: EasyKey;
    const KEY_N: EasyKey;
    const KEY_O: EasyKey;
    const KEY_P: EasyKey;
    const KEY_Q: EasyKey;
    const KEY_R: EasyKey;
    const KEY_S: EasyKey;
    const KEY_T: EasyKey;
    const KEY_U: EasyKey;
    const KEY_V: EasyKey;
    const KEY_W: EasyKey;
    const KEY_X: EasyKey;
    const KEY_Y: EasyKey;
    const KEY_Z: EasyKey;
    const MULTIPLY: EasyKey;
    const ADD: EasyKey;
    const DECIMAL: EasyKey;
    const SUBTRACT: EasyKey;
    const DIVIDE: EasyKey;
    const F1: EasyKey;
    const F2: EasyKey;
    const F3: EasyKey;
    const F4: EasyKey;
    const F5: EasyKey;
    const F6: EasyKey;
    const F7: EasyKey;
    const F8: EasyKey;
    const F9: EasyKey;
    const F10: EasyKey;
    const F11: EasyKey;
    const F12: EasyKey;
    const F13: EasyKey;
    const F14: EasyKey;
    const F15: EasyKey;
    const F16: EasyKey;
    const F17: EasyKey;
    const F18: EasyKey;
    const F19: EasyKey;
    const F20: EasyKey;
    const F21: EasyKey;
    const F22: EasyKey;
    const F23: EasyKey;
    const F24: EasyKey;
    const NUM_LOCK: EasyKey;
    const COMMA: EasyKey;
    const PERIOD: EasyKey;
    const SLASH: EasyKey;
    const SEMICOLON: EasyKey;
    const QUOTE: EasyKey;
    const BRACKET_LEFT: EasyKey;
    const BRACKET_RIGHT: EasyKey;
    const BACKQUOTE: EasyKey;
    const BACKSLASH: EasyKey;
    const MINUS: EasyKey;
    const EQUAL: EasyKey;
    const INTL_RO: EasyKey;
    const INTL_YEN: EasyKey;
}
export declare namespace Key {
    function isKey(arg: any): arg is Key;
    function getKey(arg: string | number): Key | undefined;
    function getEasyKey(key: Key): EasyKey;
    function isModifier(arg: string | number): boolean;
    function equals(key: Key, keyCode: KeyCode): boolean;
    const BACKSPACE: Key;
    const TAB: Key;
    const ENTER: Key;
    const ESCAPE: Key;
    const SPACE: Key;
    const PAGE_UP: Key;
    const PAGE_DOWN: Key;
    const END: Key;
    const HOME: Key;
    const ARROW_LEFT: Key;
    const ARROW_UP: Key;
    const ARROW_RIGHT: Key;
    const ARROW_DOWN: Key;
    const INSERT: Key;
    const DELETE: Key;
    const SHIFT_LEFT: Key;
    const SHIFT_RIGHT: Key;
    const CONTROL_LEFT: Key;
    const CONTROL_RIGHT: Key;
    const ALT_LEFT: Key;
    const ALT_RIGHT: Key;
    const CAPS_LOCK: Key;
    const OS_LEFT: Key;
    const OS_RIGHT: Key;
    const DIGIT0: Key;
    const DIGIT1: Key;
    const DIGIT2: Key;
    const DIGIT3: Key;
    const DIGIT4: Key;
    const DIGIT5: Key;
    const DIGIT6: Key;
    const DIGIT7: Key;
    const DIGIT8: Key;
    const DIGIT9: Key;
    const KEY_A: Key;
    const KEY_B: Key;
    const KEY_C: Key;
    const KEY_D: Key;
    const KEY_E: Key;
    const KEY_F: Key;
    const KEY_G: Key;
    const KEY_H: Key;
    const KEY_I: Key;
    const KEY_J: Key;
    const KEY_K: Key;
    const KEY_L: Key;
    const KEY_M: Key;
    const KEY_N: Key;
    const KEY_O: Key;
    const KEY_P: Key;
    const KEY_Q: Key;
    const KEY_R: Key;
    const KEY_S: Key;
    const KEY_T: Key;
    const KEY_U: Key;
    const KEY_V: Key;
    const KEY_W: Key;
    const KEY_X: Key;
    const KEY_Y: Key;
    const KEY_Z: Key;
    const MULTIPLY: Key;
    const ADD: Key;
    const DECIMAL: Key;
    const SUBTRACT: Key;
    const DIVIDE: Key;
    const F1: Key;
    const F2: Key;
    const F3: Key;
    const F4: Key;
    const F5: Key;
    const F6: Key;
    const F7: Key;
    const F8: Key;
    const F9: Key;
    const F10: Key;
    const F11: Key;
    const F12: Key;
    const F13: Key;
    const F14: Key;
    const F15: Key;
    const F16: Key;
    const F17: Key;
    const F18: Key;
    const F19: Key;
    const F20: Key;
    const F21: Key;
    const F22: Key;
    const F23: Key;
    const F24: Key;
    const NUM_LOCK: Key;
    const SEMICOLON: Key;
    const EQUAL: Key;
    const COMMA: Key;
    const MINUS: Key;
    const PERIOD: Key;
    const SLASH: Key;
    const BACKQUOTE: Key;
    const INTL_RO: Key;
    const BRACKET_LEFT: Key;
    const BACKSLASH: Key;
    const BRACKET_RIGHT: Key;
    const QUOTE: Key;
    const INTL_YEN: Key;
}
export declare type KeysOrKeyCodes = Key | KeyCode | (Key | KeyCode)[];
export declare namespace KeysOrKeyCodes {
    const toKeyCode: (keyOrKeyCode: Key | KeyCode) => KeyCode;
    const toKeyCodes: (keysOrKeyCodes: KeysOrKeyCodes) => KeyCode[];
}
//# sourceMappingURL=keys.d.ts.map