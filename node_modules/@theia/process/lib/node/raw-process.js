"use strict";
/********************************************************************************
 * Copyright (C) 2017 Ericsson and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var inversify_1 = require("inversify");
var process_manager_1 = require("./process-manager");
var common_1 = require("@theia/core/lib/common");
var process_1 = require("./process");
var child_process_1 = require("child_process");
var stream = require("stream");
exports.RawProcessOptions = Symbol('RawProcessOptions');
exports.RawProcessFactory = Symbol('RawProcessFactory');
/* A Node stream like /dev/null.

   Writing goes to a black hole, reading returns EOF.  */
var DevNullStream = /** @class */ (function (_super) {
    __extends(DevNullStream, _super);
    function DevNullStream() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // tslint:disable-next-line:no-any
    DevNullStream.prototype._write = function (chunk, encoding, callback) {
        callback();
    };
    DevNullStream.prototype._read = function (size) {
        // tslint:disable-next-line:no-null-keyword
        this.push(null);
    };
    return DevNullStream;
}(stream.Duplex));
var RawProcess = /** @class */ (function (_super) {
    __extends(RawProcess, _super);
    function RawProcess(options, processManager, logger) {
        var _this = _super.call(this, processManager, logger, process_1.ProcessType.Raw, options) || this;
        var executable = _this.isForkOptions(options) ? options.modulePath : options.command;
        _this.logger.debug("Starting raw process: " + executable + ","
            + (" with args: " + (options.args ? options.args.join(' ') : '') + ", ")
            + (" with options: " + JSON.stringify(options.options)));
        /* spawn can throw exceptions, for example if the file is not
           executable, it throws an error with EACCES.  Here, we try to
           normalize the error handling by calling the error handler
           instead.  */
        try {
            if (_this.isForkOptions(options)) {
                _this.process = child_process_1.fork(options.modulePath, options.args, options.options);
            }
            else {
                _this.process = child_process_1.spawn(options.command, options.args, options.options);
            }
            _this.process.on('error', _this.emitOnError.bind(_this));
            _this.process.on('exit', function (exitCode, signal) {
                // node's child_process exit sets the unused parameter to null,
                // but we want it to be undefined instead.
                _this.emitOnExit(exitCode !== null ? exitCode : undefined, signal !== null ? signal : undefined);
            });
            _this.output = _this.process.stdout;
            _this.input = _this.process.stdin;
            _this.errorOutput = _this.process.stderr;
        }
        catch (error) {
            /* When an error is thrown, set up some fake streams, so the client
               code doesn't break because these field are undefined.  */
            _this.output = new DevNullStream();
            _this.input = new DevNullStream();
            _this.errorOutput = new DevNullStream();
            /* Call the client error handler, but first give them a chance to register it.  */
            process.nextTick(function () {
                _this.errorEmitter.fire(error);
            });
        }
        return _this;
    }
    Object.defineProperty(RawProcess.prototype, "pid", {
        get: function () {
            return this.process.pid;
        },
        enumerable: true,
        configurable: true
    });
    RawProcess.prototype.kill = function (signal) {
        if (this.killed === false) {
            this.process.kill(signal);
        }
    };
    RawProcess = __decorate([
        inversify_1.injectable(),
        __param(0, inversify_1.inject(exports.RawProcessOptions)),
        __param(1, inversify_1.inject(process_manager_1.ProcessManager)),
        __param(2, inversify_1.inject(common_1.ILogger)), __param(2, inversify_1.named('process')),
        __metadata("design:paramtypes", [Object, process_manager_1.ProcessManager, Object])
    ], RawProcess);
    return RawProcess;
}(process_1.Process));
exports.RawProcess = RawProcess;
//# sourceMappingURL=raw-process.js.map