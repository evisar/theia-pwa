"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
/********************************************************************************
 * Copyright (C) 2018 Red Hat, Inc. and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var event_1 = require("@theia/core/lib/common/event");
var types_impl_1 = require("../../types-impl");
var plugin_api_1 = require("../../../api/plugin-api");
var uuid = require("uuid");
var connection_1 = require("../../../common/connection");
var plugin_debug_adapter_session_1 = require("./plugin-debug-adapter-session");
var plugin_debug_adapter_starter_1 = require("./plugin-debug-adapter-starter");
var plugin_debug_adapter_executable_resolver_1 = require("./plugin-debug-adapter-executable-resolver");
var vscode_uri_1 = require("vscode-uri");
var path_1 = require("@theia/core/lib/common/path");
// tslint:disable:no-any
/**
 * It is supposed to work at node only.
 */
var DebugExtImpl = /** @class */ (function () {
    function DebugExtImpl(rpc) {
        var _this = this;
        // debug sessions by sessionId
        this.sessions = new Map();
        // providers by type
        this.configurationProviders = new Map();
        this.debuggersContributions = new Map();
        this.onDidChangeBreakpointsEmitter = new event_1.Emitter();
        this.onDidChangeActiveDebugSessionEmitter = new event_1.Emitter();
        this.onDidTerminateDebugSessionEmitter = new event_1.Emitter();
        this.onDidStartDebugSessionEmitter = new event_1.Emitter();
        this.onDidReceiveDebugSessionCustomEmitter = new event_1.Emitter();
        this.breakpoints = [];
        this.proxy = rpc.getProxy(plugin_api_1.PLUGIN_RPC_CONTEXT.DEBUG_MAIN);
        this.activeDebugConsole = {
            append: function (value) { return _this.proxy.$appendToDebugConsole(value); },
            appendLine: function (value) { return _this.proxy.$appendLineToDebugConsole(value); }
        };
    }
    /**
     * Sets dependencies.
     */
    DebugExtImpl.prototype.assistedInject = function (connectionExt, commandRegistryExt) {
        this.connectionExt = connectionExt;
        this.commandRegistryExt = commandRegistryExt;
    };
    /**
     * Registers contributions.
     * @param pluginFolder plugin folder path
     * @param contributions available debuggers contributions
     */
    DebugExtImpl.prototype.registerDebuggersContributions = function (pluginFolder, contributions) {
        var _this = this;
        this.pluginFolder = pluginFolder;
        contributions.forEach(function (contribution) {
            _this.debuggersContributions.set(contribution.type, contribution);
            _this.proxy.$registerDebuggerContribution({
                type: contribution.type,
                label: contribution.label || contribution.type
            });
            console.log("Debugger contribution has been registered: " + contribution.type);
        });
    };
    Object.defineProperty(DebugExtImpl.prototype, "onDidReceiveDebugSessionCustomEvent", {
        get: function () {
            return this.onDidReceiveDebugSessionCustomEmitter.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugExtImpl.prototype, "onDidChangeActiveDebugSession", {
        get: function () {
            return this.onDidChangeActiveDebugSessionEmitter.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugExtImpl.prototype, "onDidTerminateDebugSession", {
        get: function () {
            return this.onDidTerminateDebugSessionEmitter.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugExtImpl.prototype, "onDidStartDebugSession", {
        get: function () {
            return this.onDidStartDebugSessionEmitter.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugExtImpl.prototype, "onDidChangeBreakpoints", {
        get: function () {
            return this.onDidChangeBreakpointsEmitter.event;
        },
        enumerable: true,
        configurable: true
    });
    DebugExtImpl.prototype.addBreakpoints = function (breakpoints) {
        this.proxy.$addBreakpoints(breakpoints);
    };
    DebugExtImpl.prototype.removeBreakpoints = function (breakpoints) {
        this.proxy.$removeBreakpoints(breakpoints);
    };
    DebugExtImpl.prototype.startDebugging = function (folder, nameOrConfiguration) {
        return this.proxy.$startDebugging(folder, nameOrConfiguration);
    };
    DebugExtImpl.prototype.registerDebugConfigurationProvider = function (debugType, provider) {
        var _this = this;
        console.log("Debug configuration provider has been registered: " + debugType);
        var providers = this.configurationProviders.get(debugType) || new Set();
        this.configurationProviders.set(debugType, providers);
        providers.add(provider);
        return types_impl_1.Disposable.create(function () {
            // tslint:disable-next-line:no-shadowed-variable
            var providers = _this.configurationProviders.get(debugType);
            if (providers) {
                providers.delete(provider);
                if (providers.size === 0) {
                    _this.configurationProviders.delete(debugType);
                }
            }
        });
    };
    DebugExtImpl.prototype.$onSessionCustomEvent = function (sessionId, event, body) {
        return __awaiter(this, void 0, void 0, function () {
            var session;
            return __generator(this, function (_a) {
                session = this.sessions.get(sessionId);
                if (session) {
                    this.onDidReceiveDebugSessionCustomEmitter.fire({ event: event, body: body, session: session });
                }
                return [2 /*return*/];
            });
        });
    };
    DebugExtImpl.prototype.$sessionDidCreate = function (sessionId) {
        return __awaiter(this, void 0, void 0, function () {
            var session;
            return __generator(this, function (_a) {
                session = this.sessions.get(sessionId);
                if (session) {
                    this.onDidStartDebugSessionEmitter.fire(session);
                }
                return [2 /*return*/];
            });
        });
    };
    DebugExtImpl.prototype.$sessionDidDestroy = function (sessionId) {
        return __awaiter(this, void 0, void 0, function () {
            var session;
            return __generator(this, function (_a) {
                session = this.sessions.get(sessionId);
                if (session) {
                    this.onDidTerminateDebugSessionEmitter.fire(session);
                }
                return [2 /*return*/];
            });
        });
    };
    DebugExtImpl.prototype.$sessionDidChange = function (sessionId) {
        return __awaiter(this, void 0, void 0, function () {
            var activeDebugSession;
            return __generator(this, function (_a) {
                activeDebugSession = sessionId ? this.sessions.get(sessionId) : undefined;
                this.onDidChangeActiveDebugSessionEmitter.fire(activeDebugSession);
                return [2 /*return*/];
            });
        });
    };
    DebugExtImpl.prototype.$breakpointsDidChange = function (all, added, removed, changed) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.breakpoints = all;
                this.onDidChangeBreakpointsEmitter.fire({ added: added, removed: removed, changed: changed });
                return [2 /*return*/];
            });
        });
    };
    DebugExtImpl.prototype.$createDebugSession = function (debugConfiguration) {
        return __awaiter(this, void 0, void 0, function () {
            var executable, communicationProvider, sessionId, debugAdapterSession, connection;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getExecutable(debugConfiguration)];
                    case 1:
                        executable = _a.sent();
                        communicationProvider = plugin_debug_adapter_starter_1.startDebugAdapter(executable);
                        sessionId = uuid.v4();
                        debugAdapterSession = new plugin_debug_adapter_session_1.PluginDebugAdapterSession(sessionId, debugConfiguration, communicationProvider, function (command, args) { return _this.proxy.$customRequest(command, args); });
                        this.sessions.set(sessionId, debugAdapterSession);
                        return [4 /*yield*/, this.connectionExt.ensureConnection(sessionId)];
                    case 2:
                        connection = _a.sent();
                        debugAdapterSession.start(new connection_1.PluginWebSocketChannel(connection));
                        return [2 /*return*/, sessionId];
                }
            });
        });
    };
    DebugExtImpl.prototype.$terminateDebugSession = function (sessionId) {
        return __awaiter(this, void 0, void 0, function () {
            var debugAdapterSession;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        debugAdapterSession = this.sessions.get(sessionId);
                        if (!debugAdapterSession) return [3 /*break*/, 2];
                        return [4 /*yield*/, debugAdapterSession.stop()];
                    case 1:
                        _a.sent();
                        this.sessions.delete(sessionId);
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    DebugExtImpl.prototype.$getSupportedLanguages = function (debugType) {
        return __awaiter(this, void 0, void 0, function () {
            var contribution;
            return __generator(this, function (_a) {
                contribution = this.debuggersContributions.get(debugType);
                return [2 /*return*/, contribution && contribution.languages || []];
            });
        });
    };
    DebugExtImpl.prototype.$getSchemaAttributes = function (debugType) {
        return __awaiter(this, void 0, void 0, function () {
            var contribution;
            return __generator(this, function (_a) {
                contribution = this.debuggersContributions.get(debugType);
                return [2 /*return*/, contribution && contribution.configurationAttributes || []];
            });
        });
    };
    DebugExtImpl.prototype.$getConfigurationSnippets = function (debugType) {
        return __awaiter(this, void 0, void 0, function () {
            var contribution;
            return __generator(this, function (_a) {
                contribution = this.debuggersContributions.get(debugType);
                return [2 /*return*/, contribution && contribution.configurationSnippets || []];
            });
        });
    };
    DebugExtImpl.prototype.$provideDebugConfigurations = function (debugType, workspaceFolderUri) {
        return __awaiter(this, void 0, void 0, function () {
            var e_1, _a, result, providers, providers_1, providers_1_1, provider, _b, _c, e_1_1;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        result = [];
                        providers = this.configurationProviders.get(debugType);
                        if (!providers) return [3 /*break*/, 8];
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 6, 7, 8]);
                        providers_1 = __values(providers), providers_1_1 = providers_1.next();
                        _d.label = 2;
                    case 2:
                        if (!!providers_1_1.done) return [3 /*break*/, 5];
                        provider = providers_1_1.value;
                        if (!provider.provideDebugConfigurations) return [3 /*break*/, 4];
                        _c = (_b = result).concat;
                        return [4 /*yield*/, provider.provideDebugConfigurations(this.toWorkspaceFolder(workspaceFolderUri))];
                    case 3:
                        result = _c.apply(_b, [(_d.sent()) || []]);
                        _d.label = 4;
                    case 4:
                        providers_1_1 = providers_1.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_1_1 = _d.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (providers_1_1 && !providers_1_1.done && (_a = providers_1.return)) _a.call(providers_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/, result];
                }
            });
        });
    };
    DebugExtImpl.prototype.$resolveDebugConfigurations = function (debugConfiguration, workspaceFolderUri) {
        return __awaiter(this, void 0, void 0, function () {
            var e_2, _a, current, providers, providers_2, providers_2_1, provider, next, e_3, e_2_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        current = debugConfiguration;
                        providers = this.configurationProviders.get(debugConfiguration.type);
                        if (!providers) return [3 /*break*/, 10];
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 8, 9, 10]);
                        providers_2 = __values(providers), providers_2_1 = providers_2.next();
                        _b.label = 2;
                    case 2:
                        if (!!providers_2_1.done) return [3 /*break*/, 7];
                        provider = providers_2_1.value;
                        if (!provider.resolveDebugConfiguration) return [3 /*break*/, 6];
                        _b.label = 3;
                    case 3:
                        _b.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, provider.resolveDebugConfiguration(this.toWorkspaceFolder(workspaceFolderUri), current)];
                    case 4:
                        next = _b.sent();
                        if (next) {
                            current = next;
                        }
                        else {
                            return [2 /*return*/, current];
                        }
                        return [3 /*break*/, 6];
                    case 5:
                        e_3 = _b.sent();
                        console.error(e_3);
                        return [3 /*break*/, 6];
                    case 6:
                        providers_2_1 = providers_2.next();
                        return [3 /*break*/, 2];
                    case 7: return [3 /*break*/, 10];
                    case 8:
                        e_2_1 = _b.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 10];
                    case 9:
                        try {
                            if (providers_2_1 && !providers_2_1.done && (_a = providers_2.return)) _a.call(providers_2);
                        }
                        finally { if (e_2) throw e_2.error; }
                        return [7 /*endfinally*/];
                    case 10: return [2 /*return*/, current];
                }
            });
        });
    };
    DebugExtImpl.prototype.getExecutable = function (debugConfiguration) {
        return __awaiter(this, void 0, void 0, function () {
            var contribution;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        contribution = this.debuggersContributions.get(debugConfiguration.type);
                        if (!contribution) return [3 /*break*/, 3];
                        if (!contribution.adapterExecutableCommand) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.commandRegistryExt.executeCommand(contribution.adapterExecutableCommand, [])];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2: return [2 /*return*/, plugin_debug_adapter_executable_resolver_1.resolveDebugAdapterExecutable(this.pluginFolder, contribution)];
                    case 3: throw new Error("It is not possible to provide debug adapter executable for '" + debugConfiguration.type + "'.");
                }
            });
        });
    };
    DebugExtImpl.prototype.toWorkspaceFolder = function (folder) {
        if (!folder) {
            return undefined;
        }
        var uri = vscode_uri_1.default.parse(folder);
        var path = new path_1.Path(uri.path);
        return {
            uri: uri,
            name: path.base,
            index: 0
        };
    };
    return DebugExtImpl;
}());
exports.DebugExtImpl = DebugExtImpl;
//# sourceMappingURL=debug.js.map