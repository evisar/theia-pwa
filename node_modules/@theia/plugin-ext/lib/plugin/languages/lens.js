"use strict";
/********************************************************************************
 * Copyright (C) 2018 Red Hat, Inc. and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
var Converter = require("../type-converters");
var object_identifier_1 = require("../../common/object-identifier");
var token_provider_1 = require("../token-provider");
/** Adapts the calls from main to extension thread for providing/resolving the code lenses. */
var CodeLensAdapter = /** @class */ (function () {
    function CodeLensAdapter(provider, documents, commands) {
        this.provider = provider;
        this.documents = documents;
        this.commands = commands;
        this.cacheId = 0;
        this.cache = new Map();
    }
    CodeLensAdapter.prototype.provideCodeLenses = function (resource) {
        var _this = this;
        var document = this.documents.getDocumentData(resource);
        if (!document) {
            return Promise.reject(new Error("There is no document for " + resource));
        }
        var doc = document.document;
        return Promise.resolve(this.provider.provideCodeLenses(doc, token_provider_1.createToken())).then(function (lenses) {
            if (Array.isArray(lenses)) {
                return lenses.map(function (lens) {
                    var id = _this.cacheId++;
                    var lensSymbol = object_identifier_1.ObjectIdentifier.mixin({
                        range: Converter.fromRange(lens.range),
                        command: _this.commands.toInternal(lens.command)
                    }, id);
                    _this.cache.set(id, lens);
                    return lensSymbol;
                });
            }
            return undefined;
        });
    };
    CodeLensAdapter.prototype.resolveCodeLens = function (resource, symbol) {
        var _this = this;
        var lens = this.cache.get(object_identifier_1.ObjectIdentifier.of(symbol));
        if (!lens) {
            return Promise.resolve(undefined);
        }
        var resolve;
        if (typeof this.provider.resolveCodeLens !== 'function' || lens.isResolved) {
            resolve = Promise.resolve(lens);
        }
        else {
            resolve = Promise.resolve(this.provider.resolveCodeLens(lens, token_provider_1.createToken()));
        }
        return resolve.then(function (newLens) {
            newLens = newLens || lens;
            symbol.command = _this.commands.toInternal(newLens.command || CodeLensAdapter.BAD_CMD);
            return symbol;
        });
    };
    CodeLensAdapter.BAD_CMD = { id: 'missing', label: '<<MISSING COMMAND>>' };
    return CodeLensAdapter;
}());
exports.CodeLensAdapter = CodeLensAdapter;
//# sourceMappingURL=lens.js.map