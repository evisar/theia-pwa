"use strict";
/********************************************************************************
 * Copyright (C) 2018 Red Hat, Inc. and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// copied from https://github.com/Microsoft/vscode/blob/master/src/vs/workbench/services/extensions/node/rpcProtocol.ts
// with small modifications
Object.defineProperty(exports, "__esModule", { value: true });
var promise_util_1 = require("@theia/core/lib/common/promise-util");
var ProxyIdentifier = /** @class */ (function () {
    function ProxyIdentifier(isMain, id) {
        this.isMain = isMain;
        // TODO this is nasty, rewrite this
        this.id = id.toString();
    }
    return ProxyIdentifier;
}());
exports.ProxyIdentifier = ProxyIdentifier;
function createProxyIdentifier(identifier) {
    return new ProxyIdentifier(false, identifier);
}
exports.createProxyIdentifier = createProxyIdentifier;
var RPCProtocolImpl = /** @class */ (function () {
    function RPCProtocolImpl(connection, remoteHostID) {
        var _this = this;
        this.remoteHostID = remoteHostID;
        this.isDisposed = false;
        // tslint:disable-next-line:no-null-keyword
        this.locals = Object.create(null);
        // tslint:disable-next-line:no-null-keyword
        this.proxies = Object.create(null);
        this.lastMessageId = 0;
        // tslint:disable-next-line:no-null-keyword
        this.invokedHandlers = Object.create(null);
        this.pendingRPCReplies = {};
        this.multiplexor = new RPCMultiplexer(connection, function (msg) { return _this.receiveOneMessage(msg); }, remoteHostID);
    }
    RPCProtocolImpl.prototype.getProxy = function (proxyId) {
        if (!this.proxies[proxyId.id]) {
            this.proxies[proxyId.id] = this.createProxy(proxyId.id);
        }
        return this.proxies[proxyId.id];
    };
    RPCProtocolImpl.prototype.set = function (identifier, instance) {
        this.locals[identifier.id] = instance;
        return instance;
    };
    RPCProtocolImpl.prototype.createProxy = function (proxyId) {
        var _this = this;
        var handler = {
            get: function (target, name) {
                if (!target[name] && name.charCodeAt(0) === 36 /* CharCode.DollarSign */) {
                    target[name] = function () {
                        var myArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            myArgs[_i] = arguments[_i];
                        }
                        return _this.remoteCall(proxyId, name, myArgs);
                    };
                }
                return target[name];
            }
        };
        // tslint:disable-next-line:no-null-keyword
        return new Proxy(Object.create(null), handler);
    };
    RPCProtocolImpl.prototype.remoteCall = function (proxyId, methodName, args) {
        if (this.isDisposed) {
            return Promise.reject(canceled());
        }
        var callId = String(++this.lastMessageId);
        var result = new promise_util_1.Deferred();
        this.pendingRPCReplies[callId] = result;
        this.multiplexor.send(MessageFactory.request(callId, proxyId, methodName, args, this.messageToSendHostId));
        return result.promise;
    };
    RPCProtocolImpl.prototype.receiveOneMessage = function (rawmsg) {
        if (this.isDisposed) {
            return;
        }
        var msg = JSON.parse(rawmsg);
        // handle message that sets the Host ID
        if (msg.setHostID) {
            this.messageToSendHostId = msg.setHostID;
            return;
        }
        // skip message if not matching host
        if (this.remoteHostID && msg.hostID && this.remoteHostID !== msg.hostID) {
            return;
        }
        switch (msg.type) {
            case 1 /* Request */:
                this.receiveRequest(msg);
                break;
            case 2 /* Reply */:
                this.receiveReply(msg);
                break;
            case 3 /* ReplyErr */:
                this.receiveReplyErr(msg);
                break;
        }
    };
    RPCProtocolImpl.prototype.receiveRequest = function (msg) {
        var _this = this;
        var callId = msg.id;
        var proxyId = msg.proxyId;
        this.invokedHandlers[callId] = this.invokeHandler(proxyId, msg.method, msg.args);
        this.invokedHandlers[callId].then(function (r) {
            delete _this.invokedHandlers[callId];
            _this.multiplexor.send(MessageFactory.replyOK(callId, r, _this.messageToSendHostId));
        }, function (err) {
            delete _this.invokedHandlers[callId];
            _this.multiplexor.send(MessageFactory.replyErr(callId, err, _this.messageToSendHostId));
        });
    };
    RPCProtocolImpl.prototype.receiveReply = function (msg) {
        var callId = msg.id;
        if (!this.pendingRPCReplies.hasOwnProperty(callId)) {
            return;
        }
        var pendingReply = this.pendingRPCReplies[callId];
        delete this.pendingRPCReplies[callId];
        pendingReply.resolve(msg.res);
    };
    RPCProtocolImpl.prototype.receiveReplyErr = function (msg) {
        var callId = msg.id;
        if (!this.pendingRPCReplies.hasOwnProperty(callId)) {
            return;
        }
        var pendingReply = this.pendingRPCReplies[callId];
        delete this.pendingRPCReplies[callId];
        var err = undefined;
        if (msg.err && msg.err.$isError) {
            err = new Error();
            err.name = msg.err.name;
            err.message = msg.err.message;
            err.stack = msg.err.stack;
        }
        pendingReply.reject(err);
    };
    RPCProtocolImpl.prototype.invokeHandler = function (proxyId, methodName, args) {
        try {
            return Promise.resolve(this.doInvokeHandler(proxyId, methodName, args));
        }
        catch (err) {
            return Promise.reject(err);
        }
    };
    RPCProtocolImpl.prototype.doInvokeHandler = function (proxyId, methodName, args) {
        if (!this.locals[proxyId]) {
            throw new Error('Unknown actor ' + proxyId);
        }
        var actor = this.locals[proxyId];
        var method = actor[methodName];
        if (typeof method !== 'function') {
            throw new Error('Unknown method ' + methodName + ' on actor ' + proxyId);
        }
        return method.apply(actor, args);
    };
    return RPCProtocolImpl;
}());
exports.RPCProtocolImpl = RPCProtocolImpl;
function canceled() {
    var error = new Error('Canceled');
    error.name = error.message;
    return error;
}
/**
 * Sends/Receives multiple messages in one go:
 *  - multiple messages to be sent from one stack get sent in bulk at `process.nextTick`.
 *  - each incoming message is handled in a separate `process.nextTick`.
 */
var RPCMultiplexer = /** @class */ (function () {
    function RPCMultiplexer(connection, onMessage, remoteHostId) {
        this.connection = connection;
        this.sendAccumulatedBound = this.sendAccumulated.bind(this);
        this.messagesToSend = [];
        if (remoteHostId) {
            this.send("{\"setHostID\":\"" + remoteHostId + "\"}");
        }
        this.connection.onMessage(function (data) {
            var len = data.length;
            for (var i = 0; i < len; i++) {
                onMessage(data[i]);
            }
        });
    }
    RPCMultiplexer.prototype.sendAccumulated = function () {
        var tmp = this.messagesToSend;
        this.messagesToSend = [];
        this.connection.send(tmp);
    };
    RPCMultiplexer.prototype.send = function (msg) {
        if (this.messagesToSend.length === 0) {
            if (typeof setImmediate !== 'undefined') {
                setImmediate(this.sendAccumulatedBound);
            }
            else {
                setTimeout(this.sendAccumulatedBound, 0);
            }
        }
        this.messagesToSend.push(msg);
    };
    return RPCMultiplexer;
}());
var MessageFactory = /** @class */ (function () {
    function MessageFactory() {
    }
    MessageFactory.request = function (req, rpcId, method, args, messageToSendHostId) {
        var prefix = '';
        if (messageToSendHostId) {
            prefix = "\"hostID\":\"" + messageToSendHostId + "\",";
        }
        return "{" + prefix + "\"type\":" + 1 /* Request */ + ",\"id\":\"" + req + "\",\"proxyId\":\"" + rpcId + "\",\"method\":\"" + method + "\",\"args\":" + JSON.stringify(args) + "}";
    };
    MessageFactory.replyOK = function (req, res, messageToSendHostId) {
        var prefix = '';
        if (messageToSendHostId) {
            prefix = "\"hostID\":\"" + messageToSendHostId + "\",";
        }
        if (typeof res === 'undefined') {
            return "{" + prefix + "\"type\":" + 2 /* Reply */ + ",\"id\":\"" + req + "\"}";
        }
        return "{" + prefix + "\"type\":" + 2 /* Reply */ + ",\"id\":\"" + req + "\",\"res\":" + JSON.stringify(res) + "}";
    };
    MessageFactory.replyErr = function (req, err, messageToSendHostId) {
        var prefix = '';
        if (messageToSendHostId) {
            prefix = "\"hostID\":\"" + messageToSendHostId + "\",";
        }
        if (err instanceof Error) {
            return "{" + prefix + "\"type\":" + 3 /* ReplyErr */ + ",\"id\":\"" + req + "\",\"err\":" + JSON.stringify(transformErrorForSerialization(err)) + "}";
        }
        return "{" + prefix + "\"type\":" + 3 /* ReplyErr */ + ",\"id\":\"" + req + "\",\"err\":null}";
    };
    return MessageFactory;
}());
var RequestMessage = /** @class */ (function () {
    function RequestMessage() {
    }
    return RequestMessage;
}());
var ReplyMessage = /** @class */ (function () {
    function ReplyMessage() {
    }
    return ReplyMessage;
}());
var ReplyErrMessage = /** @class */ (function () {
    function ReplyErrMessage() {
    }
    return ReplyErrMessage;
}());
function transformErrorForSerialization(error) {
    if (error instanceof Error) {
        var name_1 = error.name, message = error.message;
        var stack = error.stacktrace || error.stack;
        return {
            $isError: true,
            name: name_1,
            message: message,
            stack: stack
        };
    }
    // return as is
    return error;
}
exports.transformErrorForSerialization = transformErrorForSerialization;
//# sourceMappingURL=rpc-protocol.js.map