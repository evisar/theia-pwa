"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
/* --------------------------------------------------------------------------------------------
 * Copyright (c) 2018 TypeFox GmbH (http://www.typefox.io). All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var Is = require("vscode-languageserver-protocol/lib/utils/is");
var services_1 = require("./services");
var ProtocolDocumentLink;
(function (ProtocolDocumentLink) {
    function is(item) {
        return !!item && 'data' in item;
    }
    ProtocolDocumentLink.is = is;
})(ProtocolDocumentLink = exports.ProtocolDocumentLink || (exports.ProtocolDocumentLink = {}));
var ProtocolCodeLens;
(function (ProtocolCodeLens) {
    function is(item) {
        return !!item && 'data' in item;
    }
    ProtocolCodeLens.is = is;
})(ProtocolCodeLens = exports.ProtocolCodeLens || (exports.ProtocolCodeLens = {}));
var ProtocolCompletionItem;
(function (ProtocolCompletionItem) {
    function is(item) {
        return !!item && 'data' in item;
    }
    ProtocolCompletionItem.is = is;
})(ProtocolCompletionItem = exports.ProtocolCompletionItem || (exports.ProtocolCompletionItem = {}));
var MonacoToProtocolConverter = /** @class */ (function () {
    function MonacoToProtocolConverter() {
    }
    MonacoToProtocolConverter.prototype.asPosition = function (lineNumber, column) {
        var line = lineNumber === undefined || lineNumber === null ? undefined : lineNumber - 1;
        var character = column === undefined || column === null ? undefined : column - 1;
        return {
            line: line, character: character
        };
    };
    MonacoToProtocolConverter.prototype.asRange = function (range) {
        if (range === undefined) {
            return undefined;
        }
        if (range === null) {
            return null;
        }
        var start = this.asPosition(range.startLineNumber, range.startColumn);
        var end = this.asPosition(range.endLineNumber, range.endColumn);
        return {
            start: start, end: end
        };
    };
    MonacoToProtocolConverter.prototype.asTextDocumentIdentifier = function (model) {
        return {
            uri: model.uri.toString()
        };
    };
    MonacoToProtocolConverter.prototype.asTextDocumentPositionParams = function (model, position) {
        return {
            textDocument: this.asTextDocumentIdentifier(model),
            position: this.asPosition(position.lineNumber, position.column)
        };
    };
    MonacoToProtocolConverter.prototype.asCompletionParams = function (model, position, context) {
        return Object.assign(this.asTextDocumentPositionParams(model, position), {
            context: this.asCompletionContext(context)
        });
    };
    MonacoToProtocolConverter.prototype.asCompletionContext = function (context) {
        return {
            triggerKind: this.asTriggerKind(context.triggerKind),
            triggerCharacter: context.triggerCharacter
        };
    };
    MonacoToProtocolConverter.prototype.asTriggerKind = function (triggerKind) {
        switch (triggerKind) {
            case monaco.languages.SuggestTriggerKind.TriggerCharacter:
                return services_1.CompletionTriggerKind.TriggerCharacter;
            case monaco.languages.SuggestTriggerKind.TriggerForIncompleteCompletions:
                return services_1.CompletionTriggerKind.TriggerForIncompleteCompletions;
            default:
                return services_1.CompletionTriggerKind.Invoked;
        }
    };
    MonacoToProtocolConverter.prototype.asCompletionItem = function (item) {
        var result = { label: item.label };
        var protocolItem = ProtocolCompletionItem.is(item) ? item : undefined;
        if (item.detail) {
            result.detail = item.detail;
        }
        // We only send items back we created. So this can't be something else than
        // a string right now.
        if (item.documentation) {
            if (!protocolItem || !protocolItem.documentationFormat) {
                result.documentation = item.documentation;
            }
            else {
                result.documentation = this.asDocumentation(protocolItem.documentationFormat, item.documentation);
            }
        }
        if (item.filterText) {
            result.filterText = item.filterText;
        }
        this.fillPrimaryInsertText(result, item);
        if (Is.number(item.kind)) {
            result.kind = this.asCompletionItemKind(item.kind, protocolItem && protocolItem.originalItemKind);
        }
        if (item.sortText) {
            result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
            result.additionalTextEdits = this.asTextEdits(item.additionalTextEdits);
        }
        if (item.command) {
            result.command = this.asCommand(item.command);
        }
        if (item.commitCharacters) {
            result.commitCharacters = item.commitCharacters.slice();
        }
        if (item.command) {
            result.command = this.asCommand(item.command);
        }
        // TODO if (item.preselect === true || item.preselect === false) { result.preselect = item.preselect; }
        if (protocolItem) {
            if (protocolItem.data !== undefined) {
                result.data = protocolItem.data;
            }
            if (protocolItem.deprecated === true || protocolItem.deprecated === false) {
                result.deprecated = protocolItem.deprecated;
            }
        }
        return result;
    };
    MonacoToProtocolConverter.prototype.asCompletionItemKind = function (value, original) {
        if (original !== undefined) {
            return original;
        }
        return value + 1;
    };
    MonacoToProtocolConverter.prototype.asDocumentation = function (format, documentation) {
        switch (format) {
            case services_1.MarkupKind.PlainText:
                return { kind: format, value: documentation };
            case services_1.MarkupKind.Markdown:
                return { kind: format, value: documentation.value };
            default:
                return "Unsupported Markup content received. Kind is: " + format;
        }
    };
    MonacoToProtocolConverter.prototype.fillPrimaryInsertText = function (target, source) {
        var format = services_1.InsertTextFormat.PlainText;
        var text;
        var range;
        if (source.textEdit) {
            text = source.textEdit.text;
            range = this.asRange(source.textEdit.range);
        }
        else if (typeof source.insertText === 'string') {
            text = source.insertText;
        }
        else if (source.insertText) {
            format = services_1.InsertTextFormat.Snippet;
            text = source.insertText.value;
        }
        if (source.range) {
            range = this.asRange(source.range);
        }
        target.insertTextFormat = format;
        if (source.fromEdit && text && range) {
            target.textEdit = { newText: text, range: range };
        }
        else {
            target.insertText = text;
        }
    };
    MonacoToProtocolConverter.prototype.asTextEdit = function (edit) {
        var range = this.asRange(edit.range);
        return {
            range: range,
            newText: edit.text
        };
    };
    MonacoToProtocolConverter.prototype.asTextEdits = function (items) {
        var _this = this;
        if (!items) {
            return undefined;
        }
        return items.map(function (item) { return _this.asTextEdit(item); });
    };
    MonacoToProtocolConverter.prototype.asReferenceParams = function (model, position, options) {
        return {
            textDocument: this.asTextDocumentIdentifier(model),
            position: this.asPosition(position.lineNumber, position.column),
            context: { includeDeclaration: options.includeDeclaration }
        };
    };
    MonacoToProtocolConverter.prototype.asDocumentSymbolParams = function (model) {
        return {
            textDocument: this.asTextDocumentIdentifier(model)
        };
    };
    MonacoToProtocolConverter.prototype.asCodeLensParams = function (model) {
        return {
            textDocument: this.asTextDocumentIdentifier(model)
        };
    };
    MonacoToProtocolConverter.prototype.asDiagnosticSeverity = function (value) {
        switch (value) {
            case monaco.MarkerSeverity.Error:
                return services_1.DiagnosticSeverity.Error;
            case monaco.MarkerSeverity.Warning:
                return services_1.DiagnosticSeverity.Warning;
            case monaco.MarkerSeverity.Info:
                return services_1.DiagnosticSeverity.Information;
            case monaco.MarkerSeverity.Hint:
                return services_1.DiagnosticSeverity.Hint;
        }
        return undefined;
    };
    MonacoToProtocolConverter.prototype.asDiagnostic = function (marker) {
        var range = this.asRange(new monaco.Range(marker.startLineNumber, marker.startColumn, marker.endLineNumber, marker.endColumn));
        var severity = this.asDiagnosticSeverity(marker.severity);
        return services_1.Diagnostic.create(range, marker.message, severity, marker.code, marker.source);
    };
    MonacoToProtocolConverter.prototype.asDiagnostics = function (markers) {
        var _this = this;
        if (markers === void 0 || markers === null) {
            return markers;
        }
        return markers.map(function (marker) { return _this.asDiagnostic(marker); });
    };
    MonacoToProtocolConverter.prototype.asCodeActionContext = function (context) {
        if (context === void 0 || context === null) {
            return context;
        }
        var diagnostics = this.asDiagnostics(context.markers);
        return services_1.CodeActionContext.create(diagnostics, Is.string(context.only) ? [context.only] : undefined);
    };
    MonacoToProtocolConverter.prototype.asCodeActionParams = function (model, range, context) {
        return {
            textDocument: this.asTextDocumentIdentifier(model),
            range: this.asRange(range),
            context: this.asCodeActionContext(context)
        };
    };
    MonacoToProtocolConverter.prototype.asCommand = function (item) {
        if (item) {
            var args = item.arguments || [];
            return services_1.Command.create.apply(services_1.Command, [item.title, item.id].concat(args));
        }
        return undefined;
    };
    MonacoToProtocolConverter.prototype.asCodeLens = function (item) {
        var result = services_1.CodeLens.create(this.asRange(item.range));
        if (item.command) {
            result.command = this.asCommand(item.command);
        }
        if (ProtocolCodeLens.is(item)) {
            if (item.data) {
                result.data = item.data;
            }
            ;
        }
        return result;
    };
    MonacoToProtocolConverter.prototype.asFormattingOptions = function (options) {
        return { tabSize: options.tabSize, insertSpaces: options.insertSpaces };
    };
    MonacoToProtocolConverter.prototype.asDocumentFormattingParams = function (model, options) {
        return {
            textDocument: this.asTextDocumentIdentifier(model),
            options: this.asFormattingOptions(options)
        };
    };
    MonacoToProtocolConverter.prototype.asDocumentRangeFormattingParams = function (model, range, options) {
        return {
            textDocument: this.asTextDocumentIdentifier(model),
            range: this.asRange(range),
            options: this.asFormattingOptions(options)
        };
    };
    MonacoToProtocolConverter.prototype.asDocumentOnTypeFormattingParams = function (model, position, ch, options) {
        return {
            textDocument: this.asTextDocumentIdentifier(model),
            position: this.asPosition(position.lineNumber, position.column),
            ch: ch,
            options: this.asFormattingOptions(options)
        };
    };
    MonacoToProtocolConverter.prototype.asRenameParams = function (model, position, newName) {
        return {
            textDocument: this.asTextDocumentIdentifier(model),
            position: this.asPosition(position.lineNumber, position.column),
            newName: newName
        };
    };
    MonacoToProtocolConverter.prototype.asDocumentLinkParams = function (model) {
        return {
            textDocument: this.asTextDocumentIdentifier(model)
        };
    };
    MonacoToProtocolConverter.prototype.asDocumentLink = function (item) {
        var result = services_1.DocumentLink.create(this.asRange(item.range));
        if (item.url) {
            result.target = item.url;
        }
        if (ProtocolDocumentLink.is(item) && item.data) {
            result.data = item.data;
        }
        return result;
    };
    return MonacoToProtocolConverter;
}());
exports.MonacoToProtocolConverter = MonacoToProtocolConverter;
var ProtocolToMonacoConverter = /** @class */ (function () {
    function ProtocolToMonacoConverter() {
    }
    ProtocolToMonacoConverter.prototype.asResourceEdits = function (resource, edits, modelVersionId) {
        return {
            resource: resource,
            edits: this.asTextEdits(edits),
            modelVersionId: modelVersionId
        };
    };
    ProtocolToMonacoConverter.prototype.asWorkspaceEdit = function (item) {
        if (!item) {
            return undefined;
        }
        var edits = [];
        if (item.documentChanges) {
            for (var _i = 0, _a = item.documentChanges; _i < _a.length; _i++) {
                var change = _a[_i];
                var resource = monaco.Uri.parse(change.textDocument.uri);
                var version = typeof change.textDocument.version === 'number' ? change.textDocument.version : undefined;
                edits.push(this.asResourceEdits(resource, change.edits, version));
            }
        }
        else if (item.changes) {
            for (var _b = 0, _c = Object.keys(item.changes); _b < _c.length; _b++) {
                var key = _c[_b];
                var resource = monaco.Uri.parse(key);
                edits.push(this.asResourceEdits(resource, item.changes[key]));
            }
        }
        return {
            edits: edits
        };
    };
    ProtocolToMonacoConverter.prototype.asTextEdit = function (edit) {
        if (!edit) {
            return undefined;
        }
        var range = this.asRange(edit.range);
        return {
            range: range,
            text: edit.newText
        };
    };
    ProtocolToMonacoConverter.prototype.asTextEdits = function (items) {
        var _this = this;
        if (!items) {
            return undefined;
        }
        return items.map(function (item) { return _this.asTextEdit(item); });
    };
    ProtocolToMonacoConverter.prototype.asCodeLens = function (item) {
        if (!item) {
            return undefined;
        }
        var range = this.asRange(item.range);
        var result = { range: range };
        if (item.command) {
            result.command = this.asCommand(item.command);
        }
        if (item.data !== void 0 && item.data !== null) {
            result.data = item.data;
        }
        return result;
    };
    ProtocolToMonacoConverter.prototype.asCodeLenses = function (items) {
        var _this = this;
        if (!items) {
            return undefined;
        }
        return items.map(function (codeLens) { return _this.asCodeLens(codeLens); });
    };
    ProtocolToMonacoConverter.prototype.asCodeActions = function (actions) {
        var _this = this;
        return actions.map(function (action) { return _this.asCodeAction(action); });
    };
    ProtocolToMonacoConverter.prototype.asCodeAction = function (item) {
        if (services_1.CodeAction.is(item)) {
            return {
                title: item.title,
                command: this.asCommand(item.command),
                edit: this.asWorkspaceEdit(item.edit),
                diagnostics: this.asDiagnostics(item.diagnostics),
                kind: item.kind
            };
        }
        return {
            command: {
                id: item.command,
                title: item.title,
                arguments: item.arguments
            },
            title: item.title
        };
    };
    ProtocolToMonacoConverter.prototype.asCommand = function (command) {
        if (!command) {
            return undefined;
        }
        return {
            id: command.command,
            title: command.title,
            arguments: command.arguments
        };
    };
    ProtocolToMonacoConverter.prototype.asDocumentSymbol = function (value) {
        var _this = this;
        var children = value.children && value.children.map(function (c) { return _this.asDocumentSymbol(c); });
        return {
            name: value.name,
            detail: value.detail || "",
            kind: this.asSymbolKind(value.kind),
            range: this.asRange(value.range),
            selectionRange: this.asRange(value.selectionRange),
            children: children
        };
    };
    ProtocolToMonacoConverter.prototype.asDocumentSymbols = function (values) {
        var _this = this;
        if (services_1.DocumentSymbol.is(values[0])) {
            return values.map(function (s) { return _this.asDocumentSymbol(s); });
        }
        return this.asSymbolInformations(values);
    };
    ProtocolToMonacoConverter.prototype.asSymbolInformations = function (values, uri) {
        var _this = this;
        if (!values) {
            return undefined;
        }
        return values.map(function (information) { return _this.asSymbolInformation(information, uri); });
    };
    ProtocolToMonacoConverter.prototype.asSymbolInformation = function (item, uri) {
        var location = this.asLocation(uri ? __assign({}, item.location, { uri: uri.toString() }) : item.location);
        return {
            name: item.name,
            detail: '',
            containerName: item.containerName,
            kind: this.asSymbolKind(item.kind),
            range: location.range,
            selectionRange: location.range
        };
    };
    ProtocolToMonacoConverter.prototype.asSymbolKind = function (item) {
        if (item <= services_1.SymbolKind.TypeParameter) {
            // Symbol kind is one based in the protocol and zero based in code.
            return item - 1;
        }
        return monaco.languages.SymbolKind.Property;
    };
    ProtocolToMonacoConverter.prototype.asDocumentHighlights = function (values) {
        var _this = this;
        if (!values) {
            return undefined;
        }
        return values.map(function (item) { return _this.asDocumentHighlight(item); });
    };
    ProtocolToMonacoConverter.prototype.asDocumentHighlight = function (item) {
        var range = this.asRange(item.range);
        var kind = Is.number(item.kind) ? this.asDocumentHighlightKind(item.kind) : undefined;
        return { range: range, kind: kind };
    };
    ProtocolToMonacoConverter.prototype.asDocumentHighlightKind = function (item) {
        switch (item) {
            case services_1.DocumentHighlightKind.Text:
                return monaco.languages.DocumentHighlightKind.Text;
            case services_1.DocumentHighlightKind.Read:
                return monaco.languages.DocumentHighlightKind.Read;
            case services_1.DocumentHighlightKind.Write:
                return monaco.languages.DocumentHighlightKind.Write;
        }
        return monaco.languages.DocumentHighlightKind.Text;
    };
    ProtocolToMonacoConverter.prototype.asReferences = function (values) {
        var _this = this;
        if (!values) {
            return undefined;
        }
        return values.map(function (location) { return _this.asLocation(location); });
    };
    ProtocolToMonacoConverter.prototype.asDefinitionResult = function (item) {
        var _this = this;
        if (!item) {
            return undefined;
        }
        if (Is.array(item)) {
            return item.map(function (location) { return _this.asLocation(location); });
        }
        else {
            return this.asLocation(item);
        }
    };
    ProtocolToMonacoConverter.prototype.asLocation = function (item) {
        if (!item) {
            return undefined;
        }
        var uri = monaco.Uri.parse(item.uri);
        var range = this.asRange(item.range);
        return {
            uri: uri, range: range
        };
    };
    ProtocolToMonacoConverter.prototype.asSignatureHelp = function (item) {
        if (!item) {
            return undefined;
        }
        var result = {};
        if (Is.number(item.activeSignature)) {
            result.activeSignature = item.activeSignature;
        }
        else {
            // activeSignature was optional in the past
            result.activeSignature = 0;
        }
        if (Is.number(item.activeParameter)) {
            result.activeParameter = item.activeParameter;
        }
        else {
            // activeParameter was optional in the past
            result.activeParameter = 0;
        }
        if (item.signatures) {
            result.signatures = this.asSignatureInformations(item.signatures);
        }
        else {
            result.signatures = [];
        }
        return result;
    };
    ProtocolToMonacoConverter.prototype.asSignatureInformations = function (items) {
        var _this = this;
        return items.map(function (item) { return _this.asSignatureInformation(item); });
    };
    ProtocolToMonacoConverter.prototype.asSignatureInformation = function (item) {
        var result = { label: item.label };
        if (item.documentation) {
            result.documentation = this.asDocumentation(item.documentation);
        }
        if (item.parameters) {
            result.parameters = this.asParameterInformations(item.parameters);
        }
        else {
            result.parameters = [];
        }
        return result;
    };
    ProtocolToMonacoConverter.prototype.asParameterInformations = function (item) {
        var _this = this;
        return item.map(function (item) { return _this.asParameterInformation(item); });
    };
    ProtocolToMonacoConverter.prototype.asParameterInformation = function (item) {
        var result = { label: item.label };
        if (item.documentation) {
            result.documentation = this.asDocumentation(item.documentation);
        }
        ;
        return result;
    };
    ProtocolToMonacoConverter.prototype.asHover = function (hover) {
        if (!hover) {
            return undefined;
        }
        return {
            contents: this.asHoverContent(hover.contents),
            range: this.asRange(hover.range)
        };
    };
    ProtocolToMonacoConverter.prototype.asHoverContent = function (contents) {
        var _this = this;
        if (Array.isArray(contents)) {
            return contents.map(function (content) { return _this.asMarkdownString(content); });
        }
        return [this.asMarkdownString(contents)];
    };
    ProtocolToMonacoConverter.prototype.asDocumentation = function (value) {
        if (Is.string(value)) {
            return value;
        }
        if (value.kind === services_1.MarkupKind.PlainText) {
            return value.value;
        }
        return this.asMarkdownString(value);
    };
    ProtocolToMonacoConverter.prototype.asMarkdownString = function (content) {
        if (services_1.MarkupContent.is(content)) {
            return {
                value: content.value
            };
        }
        if (Is.string(content)) {
            return { value: content };
        }
        var language = content.language, value = content.value;
        return {
            value: '```' + language + '\n' + value + '\n```'
        };
    };
    ProtocolToMonacoConverter.prototype.asSeverity = function (severity) {
        if (severity === 1) {
            return monaco.MarkerSeverity.Error;
        }
        if (severity === 2) {
            return monaco.MarkerSeverity.Warning;
        }
        if (severity === 3) {
            return monaco.MarkerSeverity.Info;
        }
        return monaco.MarkerSeverity.Hint;
    };
    ProtocolToMonacoConverter.prototype.asDiagnostics = function (diagnostics) {
        var _this = this;
        if (!diagnostics) {
            return undefined;
        }
        return diagnostics.map(function (diagnostic) { return _this.asDiagnostic(diagnostic); });
    };
    ProtocolToMonacoConverter.prototype.asDiagnostic = function (diagnostic) {
        return {
            code: typeof diagnostic.code === "number" ? diagnostic.code.toString() : diagnostic.code,
            severity: this.asSeverity(diagnostic.severity),
            message: diagnostic.message,
            source: diagnostic.source,
            startLineNumber: diagnostic.range.start.line + 1,
            startColumn: diagnostic.range.start.character + 1,
            endLineNumber: diagnostic.range.end.line + 1,
            endColumn: diagnostic.range.end.character + 1,
            relatedInformation: this.asRelatedInformations(diagnostic.relatedInformation)
        };
    };
    ProtocolToMonacoConverter.prototype.asRelatedInformations = function (relatedInformation) {
        var _this = this;
        if (!relatedInformation) {
            return undefined;
        }
        return relatedInformation.map(function (item) { return _this.asRelatedInformation(item); });
    };
    ProtocolToMonacoConverter.prototype.asRelatedInformation = function (relatedInformation) {
        return {
            resource: monaco.Uri.parse(relatedInformation.location.uri),
            startLineNumber: relatedInformation.location.range.start.line + 1,
            startColumn: relatedInformation.location.range.start.character + 1,
            endLineNumber: relatedInformation.location.range.end.line + 1,
            endColumn: relatedInformation.location.range.end.character + 1,
            message: relatedInformation.message
        };
    };
    ProtocolToMonacoConverter.prototype.asCompletionResult = function (result) {
        var _this = this;
        if (!result) {
            return {
                isIncomplete: false,
                items: []
            };
        }
        if (Array.isArray(result)) {
            var items = result.map(function (item) { return _this.asCompletionItem(item); });
            return {
                isIncomplete: false,
                items: items
            };
        }
        return {
            isIncomplete: result.isIncomplete,
            items: result.items.map(this.asCompletionItem.bind(this))
        };
    };
    ProtocolToMonacoConverter.prototype.asCompletionItem = function (item) {
        var result = { label: item.label };
        if (item.detail) {
            result.detail = item.detail;
        }
        if (item.documentation) {
            result.documentation = this.asDocumentation(item.documentation);
            result.documentationFormat = Is.string(item.documentation) ? undefined : item.documentation.kind;
        }
        ;
        if (item.filterText) {
            result.filterText = item.filterText;
        }
        var insertText = this.asCompletionInsertText(item);
        if (insertText) {
            result.insertText = insertText.text;
            result.range = insertText.range;
            result.fromEdit = insertText.fromEdit;
        }
        if (Is.number(item.kind)) {
            var _a = this.asCompletionItemKind(item.kind), itemKind = _a[0], original = _a[1];
            result.kind = itemKind;
            if (original) {
                result.originalItemKind = original;
            }
        }
        if (item.sortText) {
            result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
            result.additionalTextEdits = this.asTextEdits(item.additionalTextEdits);
        }
        if (Is.stringArray(item.commitCharacters)) {
            result.commitCharacters = item.commitCharacters.slice();
        }
        if (item.command) {
            result.command = this.asCommand(item.command);
        }
        if (item.deprecated === true || item.deprecated === false) {
            result.deprecated = item.deprecated;
        }
        // TODO if (item.preselect === true || item.preselect === false) { result.preselect = item.preselect; }
        if (item.data !== undefined) {
            result.data = item.data;
        }
        return result;
    };
    ProtocolToMonacoConverter.prototype.asCompletionItemKind = function (value) {
        // Protocol item kind is 1 based, codes item kind is zero based.
        if (services_1.CompletionItemKind.Text <= value && value <= services_1.CompletionItemKind.TypeParameter) {
            return [value - 1, undefined];
        }
        ;
        return [services_1.CompletionItemKind.Text, value];
    };
    ProtocolToMonacoConverter.prototype.asCompletionInsertText = function (item) {
        if (item.textEdit) {
            var range = this.asRange(item.textEdit.range);
            var value = item.textEdit.newText;
            var text = item.insertTextFormat === services_1.InsertTextFormat.Snippet ? { value: value } : value;
            return {
                text: text, range: range, fromEdit: true
            };
        }
        if (item.insertText) {
            var value = item.insertText;
            var text = item.insertTextFormat === services_1.InsertTextFormat.Snippet ? { value: value } : value;
            return { text: text, fromEdit: false };
        }
        return undefined;
    };
    ProtocolToMonacoConverter.prototype.asDocumentLinks = function (documentLinks) {
        var _this = this;
        return documentLinks.map(function (link) { return _this.asDocumentLink(link); });
    };
    ProtocolToMonacoConverter.prototype.asDocumentLink = function (documentLink) {
        return {
            range: this.asRange(documentLink.range),
            url: documentLink.target,
            data: documentLink.data
        };
    };
    ProtocolToMonacoConverter.prototype.asRange = function (range) {
        if (range === undefined) {
            return undefined;
        }
        if (range === null) {
            return null;
        }
        var start = this.asPosition(range.start);
        var end = this.asPosition(range.end);
        if (start instanceof monaco.Position && end instanceof monaco.Position) {
            return new monaco.Range(start.lineNumber, start.column, end.lineNumber, end.column);
        }
        var startLineNumber = !start || start.lineNumber === undefined ? undefined : start.lineNumber;
        var startColumn = !start || start.column === undefined ? undefined : start.column;
        var endLineNumber = !end || end.lineNumber === undefined ? undefined : end.lineNumber;
        var endColumn = !end || end.column === undefined ? undefined : end.column;
        return { startLineNumber: startLineNumber, startColumn: startColumn, endLineNumber: endLineNumber, endColumn: endColumn };
    };
    ProtocolToMonacoConverter.prototype.asPosition = function (position) {
        if (position === undefined) {
            return undefined;
        }
        if (position === null) {
            return null;
        }
        var line = position.line, character = position.character;
        var lineNumber = line === undefined ? undefined : line + 1;
        var column = character === undefined ? undefined : character + 1;
        if (lineNumber !== undefined && column !== undefined) {
            return new monaco.Position(lineNumber, column);
        }
        return { lineNumber: lineNumber, column: column };
    };
    ProtocolToMonacoConverter.prototype.asColorInformations = function (items) {
        var _this = this;
        return items.map(function (item) { return _this.asColorInformation(item); });
    };
    ProtocolToMonacoConverter.prototype.asColorInformation = function (item) {
        return {
            range: this.asRange(item.range),
            color: item.color
        };
    };
    ProtocolToMonacoConverter.prototype.asColorPresentations = function (items) {
        var _this = this;
        return items.map(function (item) { return _this.asColorPresentation(item); });
    };
    ProtocolToMonacoConverter.prototype.asColorPresentation = function (item) {
        return {
            label: item.label,
            textEdit: this.asTextEdit(item.textEdit),
            additionalTextEdits: this.asTextEdits(item.additionalTextEdits)
        };
    };
    ProtocolToMonacoConverter.prototype.asFoldingRanges = function (items) {
        var _this = this;
        if (!items) {
            return items;
        }
        return items.map(function (item) { return _this.asFoldingRange(item); });
    };
    ProtocolToMonacoConverter.prototype.asFoldingRange = function (item) {
        return {
            start: item.startLine + 1,
            end: item.endLine + 1,
            kind: this.asFoldingRangeKind(item.kind)
        };
    };
    ProtocolToMonacoConverter.prototype.asFoldingRangeKind = function (kind) {
        if (kind) {
            switch (kind) {
                case services_1.FoldingRangeKind.Comment:
                    return monaco.languages.FoldingRangeKind.Comment;
                case services_1.FoldingRangeKind.Imports:
                    return monaco.languages.FoldingRangeKind.Imports;
                case services_1.FoldingRangeKind.Region:
                    return monaco.languages.FoldingRangeKind.Region;
            }
            ;
        }
        return undefined;
    };
    return ProtocolToMonacoConverter;
}());
exports.ProtocolToMonacoConverter = ProtocolToMonacoConverter;
//# sourceMappingURL=monaco-converter.js.map