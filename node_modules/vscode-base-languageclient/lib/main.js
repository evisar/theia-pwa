/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var cp = require("child_process");
var fs = require("fs");
var client_1 = require("./client");
var vscode_1 = require("vscode");
var vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
var colorProvider_1 = require("./colorProvider");
var configuration_1 = require("./configuration");
var implementation_1 = require("./implementation");
var typeDefinition_1 = require("./typeDefinition");
var workspaceFolders_1 = require("./workspaceFolders");
var foldingRange_1 = require("./foldingRange");
var Is = require("./utils/is");
var electron = require("./utils/electron");
var processes_1 = require("./utils/processes");
__export(require("./client"));
var Executable;
(function (Executable) {
    function is(value) {
        return Is.string(value.command);
    }
    Executable.is = is;
})(Executable || (Executable = {}));
var TransportKind;
(function (TransportKind) {
    TransportKind[TransportKind["stdio"] = 0] = "stdio";
    TransportKind[TransportKind["ipc"] = 1] = "ipc";
    TransportKind[TransportKind["pipe"] = 2] = "pipe";
    TransportKind[TransportKind["socket"] = 3] = "socket";
})(TransportKind = exports.TransportKind || (exports.TransportKind = {}));
var Transport;
(function (Transport) {
    function isSocket(value) {
        var candidate = value;
        return candidate && candidate.kind === TransportKind.socket && Is.number(candidate.port);
    }
    Transport.isSocket = isSocket;
})(Transport || (Transport = {}));
var NodeModule;
(function (NodeModule) {
    function is(value) {
        return Is.string(value.module);
    }
    NodeModule.is = is;
})(NodeModule || (NodeModule = {}));
var StreamInfo;
(function (StreamInfo) {
    function is(value) {
        var candidate = value;
        return candidate && candidate.writer !== void 0 && candidate.reader !== void 0;
    }
    StreamInfo.is = is;
})(StreamInfo || (StreamInfo = {}));
var ChildProcessInfo;
(function (ChildProcessInfo) {
    function is(value) {
        var candidate = value;
        return candidate && candidate.process !== void 0 && typeof candidate.detached === 'boolean';
    }
    ChildProcessInfo.is = is;
})(ChildProcessInfo || (ChildProcessInfo = {}));
var LanguageClient = /** @class */ (function (_super) {
    __extends(LanguageClient, _super);
    function LanguageClient(arg1, arg2, arg3, arg4, arg5) {
        var _this = this;
        var id;
        var name;
        var serverOptions;
        var clientOptions;
        var forceDebug;
        if (Is.string(arg2)) {
            id = arg1;
            name = arg2;
            serverOptions = arg3;
            clientOptions = arg4;
            forceDebug = !!arg5;
        }
        else {
            id = arg1.toLowerCase();
            name = arg1;
            serverOptions = arg2;
            clientOptions = arg3;
            forceDebug = arg4;
        }
        if (forceDebug === void 0) {
            forceDebug = false;
        }
        _this = _super.call(this, id, name, clientOptions) || this;
        _this._serverOptions = serverOptions;
        _this._forceDebug = forceDebug;
        return _this;
    }
    LanguageClient.prototype.stop = function () {
        var _this = this;
        return _super.prototype.stop.call(this).then(function () {
            if (_this._serverProcess) {
                var toCheck = _this._serverProcess;
                _this._serverProcess = undefined;
                if (_this._isDetached === void 0 || !_this._isDetached) {
                    _this.checkProcessDied(toCheck);
                }
                _this._isDetached = undefined;
            }
        });
    };
    LanguageClient.prototype.checkProcessDied = function (childProcess) {
        if (!childProcess) {
            return;
        }
        setTimeout(function () {
            // Test if the process is still alive. Throws an exception if not
            try {
                process.kill(childProcess.pid, 0);
                processes_1.terminate(childProcess);
            }
            catch (error) {
                // All is fine.
            }
        }, 2000);
    };
    LanguageClient.prototype.handleConnectionClosed = function () {
        this._serverProcess = undefined;
        _super.prototype.handleConnectionClosed.call(this);
    };
    LanguageClient.prototype.createMessageTransports = function (encoding) {
        var _this = this;
        function getEnvironment(env) {
            if (!env) {
                return process.env;
            }
            var result = Object.create(null);
            Object.keys(process.env).forEach(function (key) { return result[key] = process.env[key]; });
            Object.keys(env).forEach(function (key) { return result[key] = env[key]; });
            return result;
        }
        function startedInDebugMode() {
            var args = process.execArgv;
            if (args) {
                return args.some(function (arg) { return /^--debug=?/.test(arg) || /^--debug-brk=?/.test(arg) || /^--inspect=?/.test(arg) || /^--inspect-brk=?/.test(arg); });
            }
            ;
            return false;
        }
        var server = this._serverOptions;
        // We got a function.
        if (Is.func(server)) {
            return server().then(function (result) {
                if (client_1.MessageTransports.is(result)) {
                    _this._isDetached = !!result.detached;
                    return result;
                }
                else if (StreamInfo.is(result)) {
                    _this._isDetached = !!result.detached;
                    return { reader: new vscode_languageserver_protocol_1.StreamMessageReader(result.reader), writer: new vscode_languageserver_protocol_1.StreamMessageWriter(result.writer) };
                }
                else {
                    var cp_1;
                    if (ChildProcessInfo.is(result)) {
                        cp_1 = result.process;
                        _this._isDetached = result.detached;
                    }
                    else {
                        cp_1 = result;
                        _this._isDetached = false;
                    }
                    cp_1.stderr.on('data', function (data) { return _this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)); });
                    return { reader: new vscode_languageserver_protocol_1.StreamMessageReader(cp_1.stdout), writer: new vscode_languageserver_protocol_1.StreamMessageWriter(cp_1.stdin) };
                }
            });
        }
        var json;
        var runDebug = server;
        if (runDebug.run || runDebug.debug) {
            // We are under debugging. So use debug as well.
            if (typeof v8debug === 'object' || this._forceDebug || startedInDebugMode()) {
                json = runDebug.debug;
            }
            else {
                json = runDebug.run;
            }
        }
        else {
            json = server;
        }
        return this._getServerWorkingDir(json.options).then(function (serverWorkingDir) {
            if (NodeModule.is(json) && json.module) {
                var node_1 = json;
                var transport_1 = node_1.transport || TransportKind.stdio;
                if (node_1.runtime) {
                    var args_1 = [];
                    var options = node_1.options || Object.create(null);
                    if (options.execArgv) {
                        options.execArgv.forEach(function (element) { return args_1.push(element); });
                    }
                    args_1.push(node_1.module);
                    if (node_1.args) {
                        node_1.args.forEach(function (element) { return args_1.push(element); });
                    }
                    var execOptions_1 = Object.create(null);
                    execOptions_1.cwd = serverWorkingDir;
                    execOptions_1.env = getEnvironment(options.env);
                    var pipeName = undefined;
                    if (transport_1 === TransportKind.ipc) {
                        // exec options not correctly typed in lib
                        execOptions_1.stdio = [null, null, null, 'ipc'];
                        args_1.push('--node-ipc');
                    }
                    else if (transport_1 === TransportKind.stdio) {
                        args_1.push('--stdio');
                    }
                    else if (transport_1 === TransportKind.pipe) {
                        pipeName = vscode_languageserver_protocol_1.generateRandomPipeName();
                        args_1.push("--pipe=" + pipeName);
                    }
                    else if (Transport.isSocket(transport_1)) {
                        args_1.push("--socket=" + transport_1.port);
                    }
                    args_1.push("--clientProcessId=" + process.pid.toString());
                    if (transport_1 === TransportKind.ipc || transport_1 === TransportKind.stdio) {
                        var serverProcess = cp.spawn(node_1.runtime, args_1, execOptions_1);
                        if (!serverProcess || !serverProcess.pid) {
                            return Promise.reject("Launching server using runtime " + node_1.runtime + " failed.");
                        }
                        _this._serverProcess = serverProcess;
                        serverProcess.stderr.on('data', function (data) { return _this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)); });
                        if (transport_1 === TransportKind.ipc) {
                            serverProcess.stdout.on('data', function (data) { return _this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)); });
                            return Promise.resolve({ reader: new vscode_languageserver_protocol_1.IPCMessageReader(serverProcess), writer: new vscode_languageserver_protocol_1.IPCMessageWriter(serverProcess) });
                        }
                        else {
                            return Promise.resolve({ reader: new vscode_languageserver_protocol_1.StreamMessageReader(serverProcess.stdout), writer: new vscode_languageserver_protocol_1.StreamMessageWriter(serverProcess.stdin) });
                        }
                    }
                    else if (transport_1 == TransportKind.pipe) {
                        return vscode_languageserver_protocol_1.createClientPipeTransport(pipeName).then(function (transport) {
                            var process = cp.spawn(node_1.runtime, args_1, execOptions_1);
                            if (!process || !process.pid) {
                                return Promise.reject("Launching server using runtime " + node_1.runtime + " failed.");
                            }
                            _this._serverProcess = process;
                            process.stderr.on('data', function (data) { return _this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)); });
                            process.stdout.on('data', function (data) { return _this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)); });
                            return transport.onConnected().then(function (protocol) {
                                return { reader: protocol[0], writer: protocol[1] };
                            });
                        });
                    }
                    else if (Transport.isSocket(transport_1)) {
                        return vscode_languageserver_protocol_1.createClientSocketTransport(transport_1.port).then(function (transport) {
                            var process = cp.spawn(node_1.runtime, args_1, execOptions_1);
                            if (!process || !process.pid) {
                                return Promise.reject("Launching server using runtime " + node_1.runtime + " failed.");
                            }
                            _this._serverProcess = process;
                            process.stderr.on('data', function (data) { return _this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)); });
                            process.stdout.on('data', function (data) { return _this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)); });
                            return transport.onConnected().then(function (protocol) {
                                return { reader: protocol[0], writer: protocol[1] };
                            });
                        });
                    }
                }
                else {
                    var pipeName_1 = undefined;
                    return new Promise(function (resolve, reject) {
                        var args = node_1.args && node_1.args.slice() || [];
                        if (transport_1 === TransportKind.ipc) {
                            args.push('--node-ipc');
                        }
                        else if (transport_1 === TransportKind.stdio) {
                            args.push('--stdio');
                        }
                        else if (transport_1 === TransportKind.pipe) {
                            pipeName_1 = vscode_languageserver_protocol_1.generateRandomPipeName();
                            args.push("--pipe=" + pipeName_1);
                        }
                        else if (Transport.isSocket(transport_1)) {
                            args.push("--socket=" + transport_1.port);
                        }
                        args.push("--clientProcessId=" + process.pid.toString());
                        var options = node_1.options || Object.create(null);
                        options.execArgv = options.execArgv || [];
                        options.cwd = serverWorkingDir;
                        if (transport_1 === TransportKind.ipc || transport_1 === TransportKind.stdio) {
                            electron.fork(node_1.module, args || [], options, function (error, serverProcess) {
                                if (error || !serverProcess) {
                                    reject(error);
                                }
                                else {
                                    _this._serverProcess = serverProcess;
                                    serverProcess.stderr.on('data', function (data) { return _this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)); });
                                    if (transport_1 === TransportKind.ipc) {
                                        serverProcess.stdout.on('data', function (data) { return _this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)); });
                                        resolve({ reader: new vscode_languageserver_protocol_1.IPCMessageReader(_this._serverProcess), writer: new vscode_languageserver_protocol_1.IPCMessageWriter(_this._serverProcess) });
                                    }
                                    else {
                                        resolve({ reader: new vscode_languageserver_protocol_1.StreamMessageReader(serverProcess.stdout), writer: new vscode_languageserver_protocol_1.StreamMessageWriter(serverProcess.stdin) });
                                    }
                                }
                            });
                        }
                        else if (transport_1 === TransportKind.pipe) {
                            vscode_languageserver_protocol_1.createClientPipeTransport(pipeName_1).then(function (transport) {
                                electron.fork(node_1.module, args || [], options, function (error, cp) {
                                    if (error || !cp) {
                                        reject(error);
                                    }
                                    else {
                                        _this._serverProcess = cp;
                                        cp.stderr.on('data', function (data) { return _this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)); });
                                        cp.stdout.on('data', function (data) { return _this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)); });
                                        transport.onConnected().then(function (protocol) {
                                            resolve({ reader: protocol[0], writer: protocol[1] });
                                        });
                                    }
                                });
                            });
                        }
                        else if (Transport.isSocket(transport_1)) {
                            vscode_languageserver_protocol_1.createClientSocketTransport(transport_1.port).then(function (transport) {
                                electron.fork(node_1.module, args || [], options, function (error, cp) {
                                    if (error || !cp) {
                                        reject(error);
                                    }
                                    else {
                                        _this._serverProcess = cp;
                                        cp.stderr.on('data', function (data) { return _this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)); });
                                        cp.stdout.on('data', function (data) { return _this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)); });
                                        transport.onConnected().then(function (protocol) {
                                            resolve({ reader: protocol[0], writer: protocol[1] });
                                        });
                                    }
                                });
                            });
                        }
                    });
                }
            }
            else if (Executable.is(json) && json.command) {
                var command = json;
                var args = command.args || [];
                var options = Object.assign({}, command.options);
                options.cwd = options.cwd || serverWorkingDir;
                var serverProcess = cp.spawn(command.command, args, options);
                if (!serverProcess || !serverProcess.pid) {
                    return Promise.reject("Launching server using command " + command.command + " failed.");
                }
                serverProcess.stderr.on('data', function (data) { return _this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)); });
                _this._serverProcess = serverProcess;
                _this._isDetached = !!options.detached;
                return Promise.resolve({ reader: new vscode_languageserver_protocol_1.StreamMessageReader(serverProcess.stdout), writer: new vscode_languageserver_protocol_1.StreamMessageWriter(serverProcess.stdin) });
            }
            return Promise.reject(new Error("Unsupported server configuration " + JSON.stringify(server, null, 4)));
        });
    };
    LanguageClient.prototype.registerProposedFeatures = function () {
        this.registerFeatures(ProposedFeatures.createAll(this));
    };
    LanguageClient.prototype.registerBuiltinFeatures = function () {
        _super.prototype.registerBuiltinFeatures.call(this);
        this.registerFeature(new configuration_1.ConfigurationFeature(this));
        this.registerFeature(new typeDefinition_1.TypeDefinitionFeature(this));
        this.registerFeature(new implementation_1.ImplementationFeature(this));
        this.registerFeature(new colorProvider_1.ColorProviderFeature(this));
        this.registerFeature(new workspaceFolders_1.WorkspaceFoldersFeature(this));
        this.registerFeature(new foldingRange_1.FoldingRangeFeature(this));
    };
    LanguageClient.prototype._mainGetRootPath = function () {
        var folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
            return undefined;
        }
        var folder = folders[0];
        if (folder.uri.scheme === 'file') {
            return folder.uri.fsPath;
        }
        return undefined;
    };
    LanguageClient.prototype._getServerWorkingDir = function (options) {
        var cwd = options && options.cwd;
        if (!cwd) {
            cwd = this.clientOptions.workspaceFolder
                ? this.clientOptions.workspaceFolder.uri.fsPath
                : this._mainGetRootPath();
        }
        if (cwd) {
            // make sure the folder exists otherwise creating the process will fail
            return new Promise(function (s) {
                fs.lstat(cwd, function (err, stats) {
                    s(!err && stats.isDirectory() ? cwd : undefined);
                });
            });
        }
        return Promise.resolve(undefined);
    };
    return LanguageClient;
}(client_1.BaseLanguageClient));
exports.LanguageClient = LanguageClient;
var SettingMonitor = /** @class */ (function () {
    function SettingMonitor(_client, _setting) {
        this._client = _client;
        this._setting = _setting;
        this._listeners = [];
    }
    SettingMonitor.prototype.start = function () {
        var _this = this;
        vscode_1.workspace.onDidChangeConfiguration(this.onDidChangeConfiguration, this, this._listeners);
        this.onDidChangeConfiguration();
        return new vscode_1.Disposable(function () {
            if (_this._client.needsStop()) {
                _this._client.stop();
            }
        });
    };
    SettingMonitor.prototype.onDidChangeConfiguration = function () {
        var index = this._setting.indexOf('.');
        var primary = index >= 0 ? this._setting.substr(0, index) : this._setting;
        var rest = index >= 0 ? this._setting.substr(index + 1) : undefined;
        var enabled = rest ? vscode_1.workspace.getConfiguration(primary).get(rest, false) : vscode_1.workspace.getConfiguration(primary);
        if (enabled && this._client.needsStart()) {
            this._client.start();
        }
        else if (!enabled && this._client.needsStop()) {
            this._client.stop();
        }
    };
    return SettingMonitor;
}());
exports.SettingMonitor = SettingMonitor;
// Exporting proposed protocol.
var ProposedFeatures;
(function (ProposedFeatures) {
    function createAll(_client) {
        var result = [];
        return result;
    }
    ProposedFeatures.createAll = createAll;
})(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));
