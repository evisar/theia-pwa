/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var UUID = require("./utils/uuid");
var vscode_1 = require("vscode");
var vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
function access(target, key) {
    if (target === void 0) {
        return undefined;
    }
    return target[key];
}
var WorkspaceFoldersFeature = /** @class */ (function () {
    function WorkspaceFoldersFeature(_client) {
        this._client = _client;
        this._listeners = new Map();
    }
    Object.defineProperty(WorkspaceFoldersFeature.prototype, "messages", {
        get: function () {
            return vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type;
        },
        enumerable: true,
        configurable: true
    });
    WorkspaceFoldersFeature.prototype.fillInitializeParams = function (params) {
        var _this = this;
        var folders = vscode_1.workspace.workspaceFolders;
        if (folders === void 0) {
            params.workspaceFolders = null;
        }
        else {
            params.workspaceFolders = folders.map(function (folder) { return _this.asProtocol(folder); });
        }
    };
    WorkspaceFoldersFeature.prototype.fillClientCapabilities = function (capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.workspaceFolders = true;
    };
    WorkspaceFoldersFeature.prototype.initialize = function (capabilities) {
        var _this = this;
        var client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type, function (token) {
            var workspaceFolders = function () {
                var folders = vscode_1.workspace.workspaceFolders;
                if (folders === void 0) {
                    return null;
                }
                var result = folders.map(function (folder) {
                    return _this.asProtocol(folder);
                });
                return result;
            };
            var middleware = client.clientOptions.middleware.workspace;
            return middleware && middleware.workspaceFolders
                ? middleware.workspaceFolders(token, workspaceFolders)
                : workspaceFolders(token);
        });
        var value = access(access(access(capabilities, 'workspace'), 'workspaceFolders'), 'changeNotifications');
        var id;
        if (typeof value === 'string') {
            id = value;
        }
        else if (value === true) {
            id = UUID.generateUuid();
        }
        if (id) {
            this.register(this.messages, {
                id: id,
                registerOptions: undefined
            });
        }
    };
    WorkspaceFoldersFeature.prototype.register = function (_message, data) {
        var _this = this;
        var id = data.id;
        var client = this._client;
        var disposable = vscode_1.workspace.onDidChangeWorkspaceFolders(function (event) {
            var didChangeWorkspaceFolders = function (event) {
                var params = {
                    event: {
                        added: event.added.map(function (folder) { return _this.asProtocol(folder); }),
                        removed: event.removed.map(function (folder) { return _this.asProtocol(folder); })
                    }
                };
                _this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, params);
            };
            var middleware = client.clientOptions.middleware.workspace;
            middleware && middleware.didChangeWorkspaceFolders
                ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders)
                : didChangeWorkspaceFolders(event);
        });
        this._listeners.set(id, disposable);
    };
    WorkspaceFoldersFeature.prototype.unregister = function (id) {
        var disposable = this._listeners.get(id);
        if (disposable === void 0) {
            return;
        }
        this._listeners.delete(id);
        disposable.dispose();
    };
    WorkspaceFoldersFeature.prototype.dispose = function () {
        var e_1, _a;
        try {
            for (var _b = __values(this._listeners.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var disposable = _c.value;
                disposable.dispose();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this._listeners.clear();
    };
    WorkspaceFoldersFeature.prototype.asProtocol = function (workspaceFolder) {
        if (workspaceFolder === void 0) {
            return null;
        }
        return { uri: this._client.code2ProtocolConverter.asUri(workspaceFolder.uri), name: workspaceFolder.name };
    };
    return WorkspaceFoldersFeature;
}());
exports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
