/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var vscode_1 = require("vscode");
var vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
var c2p = require("./codeConverter");
var p2c = require("./protocolConverter");
var Is = require("./utils/is");
var async_1 = require("./utils/async");
var UUID = require("./utils/uuid");
__export(require("vscode-languageserver-protocol"));
var ConsoleLogger = /** @class */ (function () {
    function ConsoleLogger() {
    }
    ConsoleLogger.prototype.error = function (message) {
        console.error(message);
    };
    ConsoleLogger.prototype.warn = function (message) {
        console.warn(message);
    };
    ConsoleLogger.prototype.info = function (message) {
        console.info(message);
    };
    ConsoleLogger.prototype.log = function (message) {
        console.log(message);
    };
    return ConsoleLogger;
}());
function createConnection(input, output, errorHandler, closeHandler) {
    var logger = new ConsoleLogger();
    var connection = vscode_languageserver_protocol_1.createProtocolConnection(input, output, logger);
    connection.onError(function (data) { errorHandler(data[0], data[1], data[2]); });
    connection.onClose(closeHandler);
    var result = {
        listen: function () { return connection.listen(); },
        sendRequest: function (type) {
            var params = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                params[_i - 1] = arguments[_i];
            }
            return connection.sendRequest.apply(connection, __spread([Is.string(type) ? type : type.method], params));
        },
        onRequest: function (type, handler) { return connection.onRequest(Is.string(type) ? type : type.method, handler); },
        sendNotification: function (type, params) { return connection.sendNotification(Is.string(type) ? type : type.method, params); },
        onNotification: function (type, handler) { return connection.onNotification(Is.string(type) ? type : type.method, handler); },
        trace: function (value, tracer, sendNotification) {
            if (sendNotification === void 0) { sendNotification = false; }
            return connection.trace(value, tracer, sendNotification);
        },
        initialize: function (params) { return connection.sendRequest(vscode_languageserver_protocol_1.InitializeRequest.type, params); },
        shutdown: function () { return connection.sendRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, undefined); },
        exit: function () { return connection.sendNotification(vscode_languageserver_protocol_1.ExitNotification.type); },
        onLogMessage: function (handler) { return connection.onNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, handler); },
        onShowMessage: function (handler) { return connection.onNotification(vscode_languageserver_protocol_1.ShowMessageNotification.type, handler); },
        onTelemetry: function (handler) { return connection.onNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, handler); },
        didChangeConfiguration: function (params) { return connection.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, params); },
        didChangeWatchedFiles: function (params) { return connection.sendNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, params); },
        didOpenTextDocument: function (params) { return connection.sendNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, params); },
        didChangeTextDocument: function (params) { return connection.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params); },
        didCloseTextDocument: function (params) { return connection.sendNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, params); },
        didSaveTextDocument: function (params) { return connection.sendNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, params); },
        onDiagnostics: function (handler) { return connection.onNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, handler); },
        dispose: function () { return connection.dispose(); }
    };
    return result;
}
/**
 * An action to be performed when the connection is producing errors.
 */
var ErrorAction;
(function (ErrorAction) {
    /**
     * Continue running the server.
     */
    ErrorAction[ErrorAction["Continue"] = 1] = "Continue";
    /**
     * Shutdown the server.
     */
    ErrorAction[ErrorAction["Shutdown"] = 2] = "Shutdown";
})(ErrorAction = exports.ErrorAction || (exports.ErrorAction = {}));
/**
 * An action to be performed when the connection to a server got closed.
 */
var CloseAction;
(function (CloseAction) {
    /**
     * Don't restart the server. The connection stays closed.
     */
    CloseAction[CloseAction["DoNotRestart"] = 1] = "DoNotRestart";
    /**
     * Restart the server.
     */
    CloseAction[CloseAction["Restart"] = 2] = "Restart";
})(CloseAction = exports.CloseAction || (exports.CloseAction = {}));
var DefaultErrorHandler = /** @class */ (function () {
    function DefaultErrorHandler(name) {
        this.name = name;
        this.restarts = [];
    }
    DefaultErrorHandler.prototype.error = function (_error, _message, count) {
        if (count && count <= 3) {
            return ErrorAction.Continue;
        }
        return ErrorAction.Shutdown;
    };
    DefaultErrorHandler.prototype.closed = function () {
        this.restarts.push(Date.now());
        if (this.restarts.length < 5) {
            return CloseAction.Restart;
        }
        else {
            var diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
            if (diff <= 3 * 60 * 1000) {
                vscode_1.window.showErrorMessage("The " + this.name + " server crashed 5 times in the last 3 minutes. The server will not be restarted.");
                return CloseAction.DoNotRestart;
            }
            else {
                this.restarts.shift();
                return CloseAction.Restart;
            }
        }
    };
    return DefaultErrorHandler;
}());
var RevealOutputChannelOn;
(function (RevealOutputChannelOn) {
    RevealOutputChannelOn[RevealOutputChannelOn["Info"] = 1] = "Info";
    RevealOutputChannelOn[RevealOutputChannelOn["Warn"] = 2] = "Warn";
    RevealOutputChannelOn[RevealOutputChannelOn["Error"] = 3] = "Error";
    RevealOutputChannelOn[RevealOutputChannelOn["Never"] = 4] = "Never";
})(RevealOutputChannelOn = exports.RevealOutputChannelOn || (exports.RevealOutputChannelOn = {}));
var State;
(function (State) {
    State[State["Stopped"] = 1] = "Stopped";
    State[State["Running"] = 2] = "Running";
})(State = exports.State || (exports.State = {}));
var ClientState;
(function (ClientState) {
    ClientState[ClientState["Initial"] = 0] = "Initial";
    ClientState[ClientState["Starting"] = 1] = "Starting";
    ClientState[ClientState["StartFailed"] = 2] = "StartFailed";
    ClientState[ClientState["Running"] = 3] = "Running";
    ClientState[ClientState["Stopping"] = 4] = "Stopping";
    ClientState[ClientState["Stopped"] = 5] = "Stopped";
})(ClientState || (ClientState = {}));
var SupporedSymbolKinds = [
    vscode_languageserver_protocol_1.SymbolKind.File,
    vscode_languageserver_protocol_1.SymbolKind.Module,
    vscode_languageserver_protocol_1.SymbolKind.Namespace,
    vscode_languageserver_protocol_1.SymbolKind.Package,
    vscode_languageserver_protocol_1.SymbolKind.Class,
    vscode_languageserver_protocol_1.SymbolKind.Method,
    vscode_languageserver_protocol_1.SymbolKind.Property,
    vscode_languageserver_protocol_1.SymbolKind.Field,
    vscode_languageserver_protocol_1.SymbolKind.Constructor,
    vscode_languageserver_protocol_1.SymbolKind.Enum,
    vscode_languageserver_protocol_1.SymbolKind.Interface,
    vscode_languageserver_protocol_1.SymbolKind.Function,
    vscode_languageserver_protocol_1.SymbolKind.Variable,
    vscode_languageserver_protocol_1.SymbolKind.Constant,
    vscode_languageserver_protocol_1.SymbolKind.String,
    vscode_languageserver_protocol_1.SymbolKind.Number,
    vscode_languageserver_protocol_1.SymbolKind.Boolean,
    vscode_languageserver_protocol_1.SymbolKind.Array,
    vscode_languageserver_protocol_1.SymbolKind.Object,
    vscode_languageserver_protocol_1.SymbolKind.Key,
    vscode_languageserver_protocol_1.SymbolKind.Null,
    vscode_languageserver_protocol_1.SymbolKind.EnumMember,
    vscode_languageserver_protocol_1.SymbolKind.Struct,
    vscode_languageserver_protocol_1.SymbolKind.Event,
    vscode_languageserver_protocol_1.SymbolKind.Operator,
    vscode_languageserver_protocol_1.SymbolKind.TypeParameter
];
var SupportedCompletionItemKinds = [
    vscode_languageserver_protocol_1.CompletionItemKind.Text,
    vscode_languageserver_protocol_1.CompletionItemKind.Method,
    vscode_languageserver_protocol_1.CompletionItemKind.Function,
    vscode_languageserver_protocol_1.CompletionItemKind.Constructor,
    vscode_languageserver_protocol_1.CompletionItemKind.Field,
    vscode_languageserver_protocol_1.CompletionItemKind.Variable,
    vscode_languageserver_protocol_1.CompletionItemKind.Class,
    vscode_languageserver_protocol_1.CompletionItemKind.Interface,
    vscode_languageserver_protocol_1.CompletionItemKind.Module,
    vscode_languageserver_protocol_1.CompletionItemKind.Property,
    vscode_languageserver_protocol_1.CompletionItemKind.Unit,
    vscode_languageserver_protocol_1.CompletionItemKind.Value,
    vscode_languageserver_protocol_1.CompletionItemKind.Enum,
    vscode_languageserver_protocol_1.CompletionItemKind.Keyword,
    vscode_languageserver_protocol_1.CompletionItemKind.Snippet,
    vscode_languageserver_protocol_1.CompletionItemKind.Color,
    vscode_languageserver_protocol_1.CompletionItemKind.File,
    vscode_languageserver_protocol_1.CompletionItemKind.Reference,
    vscode_languageserver_protocol_1.CompletionItemKind.Folder,
    vscode_languageserver_protocol_1.CompletionItemKind.EnumMember,
    vscode_languageserver_protocol_1.CompletionItemKind.Constant,
    vscode_languageserver_protocol_1.CompletionItemKind.Struct,
    vscode_languageserver_protocol_1.CompletionItemKind.Event,
    vscode_languageserver_protocol_1.CompletionItemKind.Operator,
    vscode_languageserver_protocol_1.CompletionItemKind.TypeParameter
];
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
var DynamicFeature;
(function (DynamicFeature) {
    function is(value) {
        var candidate = value;
        return candidate && Is.func(candidate.register) && Is.func(candidate.unregister) && Is.func(candidate.dispose) && candidate.messages !== void 0;
    }
    DynamicFeature.is = is;
})(DynamicFeature || (DynamicFeature = {}));
var DocumentNotifiactions = /** @class */ (function () {
    function DocumentNotifiactions(_client, _event, _type, _middleware, _createParams, _selectorFilter) {
        this._client = _client;
        this._event = _event;
        this._type = _type;
        this._middleware = _middleware;
        this._createParams = _createParams;
        this._selectorFilter = _selectorFilter;
        this._selectors = new Map();
    }
    DocumentNotifiactions.textDocumentFilter = function (selectors, textDocument) {
        var e_1, _a;
        try {
            for (var selectors_1 = __values(selectors), selectors_1_1 = selectors_1.next(); !selectors_1_1.done; selectors_1_1 = selectors_1.next()) {
                var selector = selectors_1_1.value;
                if (vscode_1.languages.match(selector, textDocument)) {
                    return true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (selectors_1_1 && !selectors_1_1.done && (_a = selectors_1.return)) _a.call(selectors_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return false;
    };
    DocumentNotifiactions.prototype.register = function (_message, data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = this._event(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
    };
    DocumentNotifiactions.prototype.callback = function (data) {
        var _this = this;
        if (!this._selectorFilter || this._selectorFilter(this._selectors.values(), data)) {
            if (this._middleware) {
                this._middleware(data, function (data) { return _this._client.sendNotification(_this._type, _this._createParams(data)); });
            }
            else {
                this._client.sendNotification(this._type, this._createParams(data));
            }
            this.notificationSent(data);
        }
    };
    DocumentNotifiactions.prototype.notificationSent = function (_data) {
    };
    DocumentNotifiactions.prototype.unregister = function (id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    };
    DocumentNotifiactions.prototype.dispose = function () {
        this._selectors.clear();
        if (this._listener) {
            this._listener.dispose();
        }
    };
    return DocumentNotifiactions;
}());
var DidOpenTextDocumentFeature = /** @class */ (function (_super) {
    __extends(DidOpenTextDocumentFeature, _super);
    function DidOpenTextDocumentFeature(client, _syncedDocuments) {
        var _this = _super.call(this, client, vscode_1.workspace.onDidOpenTextDocument, vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, client.clientOptions.middleware.didOpen, function (textDocument) { return client.code2ProtocolConverter.asOpenTextDocumentParams(textDocument); }, DocumentNotifiactions.textDocumentFilter) || this;
        _this._syncedDocuments = _syncedDocuments;
        return _this;
    }
    Object.defineProperty(DidOpenTextDocumentFeature.prototype, "messages", {
        get: function () {
            return vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type;
        },
        enumerable: true,
        configurable: true
    });
    DidOpenTextDocumentFeature.prototype.fillClientCapabilities = function (capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    };
    DidOpenTextDocumentFeature.prototype.initialize = function (capabilities, documentSelector) {
        var textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
            this.register(this.messages, { id: UUID.generateUuid(), registerOptions: { documentSelector: documentSelector } });
        }
    };
    DidOpenTextDocumentFeature.prototype.register = function (message, data) {
        var _this = this;
        _super.prototype.register.call(this, message, data);
        if (!data.registerOptions.documentSelector) {
            return;
        }
        var documentSelector = data.registerOptions.documentSelector;
        vscode_1.workspace.textDocuments.forEach(function (textDocument) {
            var uri = textDocument.uri.toString();
            if (_this._syncedDocuments.has(uri)) {
                return;
            }
            if (vscode_1.languages.match(documentSelector, textDocument)) {
                var middleware = _this._client.clientOptions.middleware;
                var didOpen = function (textDocument) {
                    _this._client.sendNotification(_this._type, _this._createParams(textDocument));
                };
                if (middleware.didOpen) {
                    middleware.didOpen(textDocument, didOpen);
                }
                else {
                    didOpen(textDocument);
                }
                _this._syncedDocuments.set(uri, textDocument);
            }
        });
    };
    DidOpenTextDocumentFeature.prototype.notificationSent = function (textDocument) {
        _super.prototype.notificationSent.call(this, textDocument);
        this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
    };
    return DidOpenTextDocumentFeature;
}(DocumentNotifiactions));
var DidCloseTextDocumentFeature = /** @class */ (function (_super) {
    __extends(DidCloseTextDocumentFeature, _super);
    function DidCloseTextDocumentFeature(client, _syncedDocuments) {
        var _this = _super.call(this, client, vscode_1.workspace.onDidCloseTextDocument, vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, client.clientOptions.middleware.didClose, function (textDocument) { return client.code2ProtocolConverter.asCloseTextDocumentParams(textDocument); }, DocumentNotifiactions.textDocumentFilter) || this;
        _this._syncedDocuments = _syncedDocuments;
        return _this;
    }
    Object.defineProperty(DidCloseTextDocumentFeature.prototype, "messages", {
        get: function () {
            return vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type;
        },
        enumerable: true,
        configurable: true
    });
    DidCloseTextDocumentFeature.prototype.fillClientCapabilities = function (capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    };
    DidCloseTextDocumentFeature.prototype.initialize = function (capabilities, documentSelector) {
        var textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
            this.register(this.messages, { id: UUID.generateUuid(), registerOptions: { documentSelector: documentSelector } });
        }
    };
    DidCloseTextDocumentFeature.prototype.notificationSent = function (textDocument) {
        _super.prototype.notificationSent.call(this, textDocument);
        this._syncedDocuments.delete(textDocument.uri.toString());
    };
    DidCloseTextDocumentFeature.prototype.unregister = function (id) {
        var _this = this;
        var selector = this._selectors.get(id);
        // The super call removed the selector from the map
        // of selectors.
        _super.prototype.unregister.call(this, id);
        var selectors = this._selectors.values();
        this._syncedDocuments.forEach(function (textDocument) {
            if (vscode_1.languages.match(selector, textDocument) && !_this._selectorFilter(selectors, textDocument)) {
                var middleware = _this._client.clientOptions.middleware;
                var didClose = function (textDocument) {
                    _this._client.sendNotification(_this._type, _this._createParams(textDocument));
                };
                _this._syncedDocuments.delete(textDocument.uri.toString());
                if (middleware.didClose) {
                    middleware.didClose(textDocument, didClose);
                }
                else {
                    didClose(textDocument);
                }
            }
        });
    };
    return DidCloseTextDocumentFeature;
}(DocumentNotifiactions));
var DidChangeTextDocumentFeature = /** @class */ (function () {
    function DidChangeTextDocumentFeature(_client) {
        this._client = _client;
        this._changeData = new Map();
        this._forcingDelivery = false;
    }
    Object.defineProperty(DidChangeTextDocumentFeature.prototype, "messages", {
        get: function () {
            return vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type;
        },
        enumerable: true,
        configurable: true
    });
    DidChangeTextDocumentFeature.prototype.fillClientCapabilities = function (capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    };
    DidChangeTextDocumentFeature.prototype.initialize = function (capabilities, documentSelector) {
        var textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.change !== void 0 && textDocumentSyncOptions.change !== vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: Object.assign({}, { documentSelector: documentSelector }, { syncKind: textDocumentSyncOptions.change })
            });
        }
    };
    DidChangeTextDocumentFeature.prototype.register = function (_message, data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = vscode_1.workspace.onDidChangeTextDocument(this.callback, this);
        }
        this._changeData.set(data.id, {
            documentSelector: data.registerOptions.documentSelector,
            syncKind: data.registerOptions.syncKind
        });
    };
    DidChangeTextDocumentFeature.prototype.callback = function (event) {
        var e_2, _a;
        var _this = this;
        // Text document changes are send for dirty changes as well. We don't
        // have dirty / undirty events in the LSP so we ignore content changes
        // with length zero.
        if (event.contentChanges.length === 0) {
            return;
        }
        var _loop_1 = function (changeData) {
            if (vscode_1.languages.match(changeData.documentSelector, event.document)) {
                var middleware = this_1._client.clientOptions.middleware;
                if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental) {
                    var params_1 = this_1._client.code2ProtocolConverter.asChangeTextDocumentParams(event);
                    if (middleware.didChange) {
                        middleware.didChange(event, function () { return _this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params_1); });
                    }
                    else {
                        this_1._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params_1);
                    }
                }
                else if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
                    var didChange = function (event) {
                        if (_this._changeDelayer) {
                            if (_this._changeDelayer.uri !== event.document.uri.toString()) {
                                // Use this force delivery to track boolean state. Otherwise we might call two times.
                                _this.forceDelivery();
                                _this._changeDelayer.uri = event.document.uri.toString();
                            }
                            _this._changeDelayer.delayer.trigger(function () {
                                _this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, _this._client.code2ProtocolConverter.asChangeTextDocumentParams(event.document));
                            });
                        }
                        else {
                            _this._changeDelayer = {
                                uri: event.document.uri.toString(),
                                delayer: new async_1.Delayer(200)
                            };
                            _this._changeDelayer.delayer.trigger(function () {
                                _this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, _this._client.code2ProtocolConverter.asChangeTextDocumentParams(event.document));
                            }, -1);
                        }
                    };
                    if (middleware.didChange) {
                        middleware.didChange(event, didChange);
                    }
                    else {
                        didChange(event);
                    }
                }
            }
        };
        var this_1 = this;
        try {
            for (var _b = __values(this._changeData.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var changeData = _c.value;
                _loop_1(changeData);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    DidChangeTextDocumentFeature.prototype.unregister = function (id) {
        this._changeData.delete(id);
        if (this._changeData.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    };
    DidChangeTextDocumentFeature.prototype.dispose = function () {
        this._changeDelayer = undefined;
        this._forcingDelivery = false;
        this._changeData.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    };
    DidChangeTextDocumentFeature.prototype.forceDelivery = function () {
        if (this._forcingDelivery || !this._changeDelayer) {
            return;
        }
        try {
            this._forcingDelivery = true;
            this._changeDelayer.delayer.forceDelivery();
        }
        finally {
            this._forcingDelivery = false;
        }
    };
    return DidChangeTextDocumentFeature;
}());
var WillSaveFeature = /** @class */ (function (_super) {
    __extends(WillSaveFeature, _super);
    function WillSaveFeature(client) {
        return _super.call(this, client, vscode_1.workspace.onWillSaveTextDocument, vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, client.clientOptions.middleware.willSave, function (willSaveEvent) { return client.code2ProtocolConverter.asWillSaveTextDocumentParams(willSaveEvent); }, function (selectors, willSaveEvent) { return DocumentNotifiactions.textDocumentFilter(selectors, willSaveEvent.document); }) || this;
    }
    Object.defineProperty(WillSaveFeature.prototype, "messages", {
        get: function () {
            return vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type;
        },
        enumerable: true,
        configurable: true
    });
    WillSaveFeature.prototype.fillClientCapabilities = function (capabilities) {
        var value = ensure(ensure(capabilities, 'textDocument'), 'synchronization');
        value.willSave = true;
    };
    WillSaveFeature.prototype.initialize = function (capabilities, documentSelector) {
        var textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSave) {
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: { documentSelector: documentSelector }
            });
        }
    };
    return WillSaveFeature;
}(DocumentNotifiactions));
var WillSaveWaitUntilFeature = /** @class */ (function () {
    function WillSaveWaitUntilFeature(_client) {
        this._client = _client;
        this._selectors = new Map();
    }
    Object.defineProperty(WillSaveWaitUntilFeature.prototype, "messages", {
        get: function () {
            return vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type;
        },
        enumerable: true,
        configurable: true
    });
    WillSaveWaitUntilFeature.prototype.fillClientCapabilities = function (capabilities) {
        var value = ensure(ensure(capabilities, 'textDocument'), 'synchronization');
        value.willSaveWaitUntil = true;
    };
    WillSaveWaitUntilFeature.prototype.initialize = function (capabilities, documentSelector) {
        var textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSaveWaitUntil) {
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: { documentSelector: documentSelector }
            });
        }
    };
    WillSaveWaitUntilFeature.prototype.register = function (_message, data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = vscode_1.workspace.onWillSaveTextDocument(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
    };
    WillSaveWaitUntilFeature.prototype.callback = function (event) {
        var _this = this;
        if (DocumentNotifiactions.textDocumentFilter(this._selectors.values(), event.document)) {
            var middleware = this._client.clientOptions.middleware;
            var willSaveWaitUntil = function (event) {
                return _this._client.sendRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, _this._client.code2ProtocolConverter.asWillSaveTextDocumentParams(event)).then(function (edits) {
                    var vEdits = _this._client.protocol2CodeConverter.asTextEdits(edits);
                    return vEdits === void 0 ? [] : vEdits;
                });
            };
            event.waitUntil(middleware.willSaveWaitUntil
                ? middleware.willSaveWaitUntil(event, willSaveWaitUntil)
                : willSaveWaitUntil(event));
        }
    };
    WillSaveWaitUntilFeature.prototype.unregister = function (id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    };
    WillSaveWaitUntilFeature.prototype.dispose = function () {
        this._selectors.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    };
    return WillSaveWaitUntilFeature;
}());
var DidSaveTextDocumentFeature = /** @class */ (function (_super) {
    __extends(DidSaveTextDocumentFeature, _super);
    function DidSaveTextDocumentFeature(client) {
        var _this = _super.call(this, client, vscode_1.workspace.onDidSaveTextDocument, vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, client.clientOptions.middleware.didSave, function (textDocument) { return client.code2ProtocolConverter.asSaveTextDocumentParams(textDocument, _this._includeText); }, DocumentNotifiactions.textDocumentFilter) || this;
        return _this;
    }
    Object.defineProperty(DidSaveTextDocumentFeature.prototype, "messages", {
        get: function () {
            return vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type;
        },
        enumerable: true,
        configurable: true
    });
    DidSaveTextDocumentFeature.prototype.fillClientCapabilities = function (capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').didSave = true;
    };
    DidSaveTextDocumentFeature.prototype.initialize = function (capabilities, documentSelector) {
        var textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.save) {
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: Object.assign({}, { documentSelector: documentSelector }, { includeText: !!textDocumentSyncOptions.save.includeText })
            });
        }
    };
    DidSaveTextDocumentFeature.prototype.register = function (method, data) {
        this._includeText = !!data.registerOptions.includeText;
        _super.prototype.register.call(this, method, data);
    };
    return DidSaveTextDocumentFeature;
}(DocumentNotifiactions));
var FileSystemWatcherFeature = /** @class */ (function () {
    function FileSystemWatcherFeature(_client, _notifyFileEvent) {
        this._client = _client;
        this._notifyFileEvent = _notifyFileEvent;
        this._watchers = new Map();
    }
    Object.defineProperty(FileSystemWatcherFeature.prototype, "messages", {
        get: function () {
            return vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type;
        },
        enumerable: true,
        configurable: true
    });
    FileSystemWatcherFeature.prototype.fillClientCapabilities = function (capabilities) {
        ensure(ensure(capabilities, 'workspace'), 'didChangeWatchedFiles').dynamicRegistration = true;
    };
    FileSystemWatcherFeature.prototype.initialize = function (_capabilities, _documentSelector) {
    };
    FileSystemWatcherFeature.prototype.register = function (_method, data) {
        var e_3, _a;
        if (!Array.isArray(data.registerOptions.watchers)) {
            return;
        }
        var disposeables = [];
        try {
            for (var _b = __values(data.registerOptions.watchers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var watcher = _c.value;
                if (!Is.string(watcher.globPattern)) {
                    continue;
                }
                var watchCreate = true, watchChange = true, watchDelete = true;
                if (watcher.kind !== void 0 && watcher.kind !== null) {
                    watchCreate = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Create) !== 0;
                    watchChange = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Change) != 0;
                    watchDelete = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Delete) != 0;
                }
                var fileSystemWatcher = vscode_1.workspace.createFileSystemWatcher(watcher.globPattern, !watchCreate, !watchChange, !watchDelete);
                this.hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete);
                disposeables.push(fileSystemWatcher);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        this._watchers.set(data.id, disposeables);
    };
    FileSystemWatcherFeature.prototype.registerRaw = function (id, fileSystemWatchers) {
        var e_4, _a;
        var disposeables = [];
        try {
            for (var fileSystemWatchers_1 = __values(fileSystemWatchers), fileSystemWatchers_1_1 = fileSystemWatchers_1.next(); !fileSystemWatchers_1_1.done; fileSystemWatchers_1_1 = fileSystemWatchers_1.next()) {
                var fileSystemWatcher = fileSystemWatchers_1_1.value;
                this.hookListeners(fileSystemWatcher, true, true, true, disposeables);
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (fileSystemWatchers_1_1 && !fileSystemWatchers_1_1.done && (_a = fileSystemWatchers_1.return)) _a.call(fileSystemWatchers_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        this._watchers.set(id, disposeables);
    };
    FileSystemWatcherFeature.prototype.hookListeners = function (fileSystemWatcher, watchCreate, watchChange, watchDelete, listeners) {
        var _this = this;
        if (watchCreate) {
            fileSystemWatcher.onDidCreate(function (resource) { return _this._notifyFileEvent({
                uri: _this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Created
            }); }, null, listeners);
        }
        if (watchChange) {
            fileSystemWatcher.onDidChange(function (resource) { return _this._notifyFileEvent({
                uri: _this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Changed
            }); }, null, listeners);
        }
        if (watchDelete) {
            fileSystemWatcher.onDidDelete(function (resource) { return _this._notifyFileEvent({
                uri: _this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Deleted
            }); }, null, listeners);
        }
    };
    FileSystemWatcherFeature.prototype.unregister = function (id) {
        var e_5, _a;
        var disposeables = this._watchers.get(id);
        if (disposeables) {
            try {
                for (var disposeables_1 = __values(disposeables), disposeables_1_1 = disposeables_1.next(); !disposeables_1_1.done; disposeables_1_1 = disposeables_1.next()) {
                    var disposable = disposeables_1_1.value;
                    disposable.dispose();
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (disposeables_1_1 && !disposeables_1_1.done && (_a = disposeables_1.return)) _a.call(disposeables_1);
                }
                finally { if (e_5) throw e_5.error; }
            }
        }
    };
    FileSystemWatcherFeature.prototype.dispose = function () {
        this._watchers.forEach(function (disposeables) {
            var e_6, _a;
            try {
                for (var disposeables_2 = __values(disposeables), disposeables_2_1 = disposeables_2.next(); !disposeables_2_1.done; disposeables_2_1 = disposeables_2.next()) {
                    var disposable = disposeables_2_1.value;
                    disposable.dispose();
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (disposeables_2_1 && !disposeables_2_1.done && (_a = disposeables_2.return)) _a.call(disposeables_2);
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
        this._watchers.clear();
    };
    return FileSystemWatcherFeature;
}());
var TextDocumentFeature = /** @class */ (function () {
    function TextDocumentFeature(_client, _message) {
        this._client = _client;
        this._message = _message;
        this._providers = new Map();
    }
    Object.defineProperty(TextDocumentFeature.prototype, "messages", {
        get: function () {
            return this._message;
        },
        enumerable: true,
        configurable: true
    });
    TextDocumentFeature.prototype.register = function (message, data) {
        if (message.method !== this.messages.method) {
            throw new Error("Register called on wrong feature. Requested " + message.method + " but reached feature " + this.messages.method);
        }
        if (!data.registerOptions.documentSelector) {
            return;
        }
        var provider = this.registerLanguageProvider(data.registerOptions);
        if (provider) {
            this._providers.set(data.id, provider);
        }
    };
    TextDocumentFeature.prototype.unregister = function (id) {
        var provider = this._providers.get(id);
        if (provider) {
            provider.dispose();
        }
    };
    TextDocumentFeature.prototype.dispose = function () {
        this._providers.forEach(function (value) {
            value.dispose();
        });
        this._providers.clear();
    };
    return TextDocumentFeature;
}());
exports.TextDocumentFeature = TextDocumentFeature;
var WorkspaceFeature = /** @class */ (function () {
    function WorkspaceFeature(_client, _message) {
        this._client = _client;
        this._message = _message;
        this._providers = new Map();
    }
    Object.defineProperty(WorkspaceFeature.prototype, "messages", {
        get: function () {
            return this._message;
        },
        enumerable: true,
        configurable: true
    });
    WorkspaceFeature.prototype.register = function (message, data) {
        if (message.method !== this.messages.method) {
            throw new Error("Register called on wron feature. Requested " + message.method + " but reached feature " + this.messages.method);
        }
        var provider = this.registerLanguageProvider(data.registerOptions);
        if (provider) {
            this._providers.set(data.id, provider);
        }
    };
    WorkspaceFeature.prototype.unregister = function (id) {
        var provider = this._providers.get(id);
        if (provider) {
            provider.dispose();
        }
    };
    WorkspaceFeature.prototype.dispose = function () {
        this._providers.forEach(function (value) {
            value.dispose();
        });
        this._providers.clear();
    };
    return WorkspaceFeature;
}());
var CompletionItemFeature = /** @class */ (function (_super) {
    __extends(CompletionItemFeature, _super);
    function CompletionItemFeature(client) {
        return _super.call(this, client, vscode_languageserver_protocol_1.CompletionRequest.type) || this;
    }
    CompletionItemFeature.prototype.fillClientCapabilities = function (capabilites) {
        var completion = ensure(ensure(capabilites, 'textDocument'), 'completion');
        completion.dynamicRegistration = true;
        completion.contextSupport = true;
        completion.completionItem = {
            snippetSupport: true,
            commitCharactersSupport: true,
            documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText],
            deprecatedSupport: true,
            preselectSupport: true
        };
        completion.completionItemKind = { valueSet: SupportedCompletionItemKinds };
    };
    CompletionItemFeature.prototype.initialize = function (capabilities, documentSelector) {
        if (!capabilities.completionProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector }, capabilities.completionProvider)
        });
    };
    CompletionItemFeature.prototype.registerLanguageProvider = function (options) {
        var triggerCharacters = options.triggerCharacters || [];
        var client = this._client;
        var provideCompletionItems = function (document, position, context, token) {
            return client.sendRequest(vscode_languageserver_protocol_1.CompletionRequest.type, client.code2ProtocolConverter.asCompletionParams(document, position, context), token).then(client.protocol2CodeConverter.asCompletionResult, function (error) {
                client.logFailedRequest(vscode_languageserver_protocol_1.CompletionRequest.type, error);
                return Promise.resolve([]);
            });
        };
        var resolveCompletionItem = function (item, token) {
            return client.sendRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, client.code2ProtocolConverter.asCompletionItem(item), token).then(client.protocol2CodeConverter.asCompletionItem, function (error) {
                client.logFailedRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, error);
                return Promise.resolve(item);
            });
        };
        var middleware = this._client.clientOptions.middleware;
        return vscode_1.languages.registerCompletionItemProvider.apply(vscode_1.languages, __spread([options.documentSelector, {
                provideCompletionItems: function (document, position, token, context) {
                    return middleware.provideCompletionItem
                        ? middleware.provideCompletionItem(document, position, context, token, provideCompletionItems)
                        : provideCompletionItems(document, position, context, token);
                },
                resolveCompletionItem: options.resolveProvider
                    ? function (item, token) {
                        return middleware.resolveCompletionItem
                            ? middleware.resolveCompletionItem(item, token, resolveCompletionItem)
                            : resolveCompletionItem(item, token);
                    }
                    : undefined
            }], triggerCharacters));
    };
    return CompletionItemFeature;
}(TextDocumentFeature));
var HoverFeature = /** @class */ (function (_super) {
    __extends(HoverFeature, _super);
    function HoverFeature(client) {
        return _super.call(this, client, vscode_languageserver_protocol_1.HoverRequest.type) || this;
    }
    HoverFeature.prototype.fillClientCapabilities = function (capabilites) {
        var hoverCapability = (ensure(ensure(capabilites, 'textDocument'), 'hover'));
        hoverCapability.dynamicRegistration = true;
        hoverCapability.contentFormat = [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText];
    };
    HoverFeature.prototype.initialize = function (capabilities, documentSelector) {
        if (!capabilities.hoverProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector })
        });
    };
    HoverFeature.prototype.registerLanguageProvider = function (options) {
        var client = this._client;
        var provideHover = function (document, position, token) {
            return client.sendRequest(vscode_languageserver_protocol_1.HoverRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asHover, function (error) {
                client.logFailedRequest(vscode_languageserver_protocol_1.HoverRequest.type, error);
                return Promise.resolve(null);
            });
        };
        var middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerHoverProvider(options.documentSelector, {
            provideHover: function (document, position, token) {
                return middleware.provideHover
                    ? middleware.provideHover(document, position, token, provideHover)
                    : provideHover(document, position, token);
            }
        });
    };
    return HoverFeature;
}(TextDocumentFeature));
var SignatureHelpFeature = /** @class */ (function (_super) {
    __extends(SignatureHelpFeature, _super);
    function SignatureHelpFeature(client) {
        return _super.call(this, client, vscode_languageserver_protocol_1.SignatureHelpRequest.type) || this;
    }
    SignatureHelpFeature.prototype.fillClientCapabilities = function (capabilites) {
        var config = ensure(ensure(capabilites, 'textDocument'), 'signatureHelp');
        config.dynamicRegistration = true;
        config.signatureInformation = { documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText] };
    };
    SignatureHelpFeature.prototype.initialize = function (capabilities, documentSelector) {
        if (!capabilities.signatureHelpProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector }, capabilities.signatureHelpProvider)
        });
    };
    SignatureHelpFeature.prototype.registerLanguageProvider = function (options) {
        var client = this._client;
        var providerSignatureHelp = function (document, position, token) {
            return client.sendRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asSignatureHelp, function (error) {
                client.logFailedRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, error);
                return Promise.resolve(null);
            });
        };
        var middleware = client.clientOptions.middleware;
        var triggerCharacters = options.triggerCharacters || [];
        return vscode_1.languages.registerSignatureHelpProvider.apply(vscode_1.languages, __spread([options.documentSelector, {
                provideSignatureHelp: function (document, position, token) {
                    return middleware.provideSignatureHelp
                        ? middleware.provideSignatureHelp(document, position, token, providerSignatureHelp)
                        : providerSignatureHelp(document, position, token);
                }
            }], triggerCharacters));
    };
    return SignatureHelpFeature;
}(TextDocumentFeature));
var DefinitionFeature = /** @class */ (function (_super) {
    __extends(DefinitionFeature, _super);
    function DefinitionFeature(client) {
        return _super.call(this, client, vscode_languageserver_protocol_1.DefinitionRequest.type) || this;
    }
    DefinitionFeature.prototype.fillClientCapabilities = function (capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'definition').dynamicRegistration = true;
    };
    DefinitionFeature.prototype.initialize = function (capabilities, documentSelector) {
        if (!capabilities.definitionProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector })
        });
    };
    DefinitionFeature.prototype.registerLanguageProvider = function (options) {
        var client = this._client;
        var provideDefinition = function (document, position, token) {
            return client.sendRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDefinitionResult, function (error) {
                client.logFailedRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, error);
                return Promise.resolve(null);
            });
        };
        var middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerDefinitionProvider(options.documentSelector, {
            provideDefinition: function (document, position, token) {
                return middleware.provideDefinition
                    ? middleware.provideDefinition(document, position, token, provideDefinition)
                    : provideDefinition(document, position, token);
            }
        });
    };
    return DefinitionFeature;
}(TextDocumentFeature));
var ReferencesFeature = /** @class */ (function (_super) {
    __extends(ReferencesFeature, _super);
    function ReferencesFeature(client) {
        return _super.call(this, client, vscode_languageserver_protocol_1.ReferencesRequest.type) || this;
    }
    ReferencesFeature.prototype.fillClientCapabilities = function (capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'references').dynamicRegistration = true;
    };
    ReferencesFeature.prototype.initialize = function (capabilities, documentSelector) {
        if (!capabilities.referencesProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector })
        });
    };
    ReferencesFeature.prototype.registerLanguageProvider = function (options) {
        var client = this._client;
        var providerReferences = function (document, position, options, token) {
            return client.sendRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, client.code2ProtocolConverter.asReferenceParams(document, position, options), token).then(client.protocol2CodeConverter.asReferences, function (error) {
                client.logFailedRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, error);
                return Promise.resolve([]);
            });
        };
        var middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerReferenceProvider(options.documentSelector, {
            provideReferences: function (document, position, options, token) {
                return middleware.provideReferences
                    ? middleware.provideReferences(document, position, options, token, providerReferences)
                    : providerReferences(document, position, options, token);
            }
        });
    };
    return ReferencesFeature;
}(TextDocumentFeature));
var DocumentHighlightFeature = /** @class */ (function (_super) {
    __extends(DocumentHighlightFeature, _super);
    function DocumentHighlightFeature(client) {
        return _super.call(this, client, vscode_languageserver_protocol_1.DocumentHighlightRequest.type) || this;
    }
    DocumentHighlightFeature.prototype.fillClientCapabilities = function (capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'documentHighlight').dynamicRegistration = true;
    };
    DocumentHighlightFeature.prototype.initialize = function (capabilities, documentSelector) {
        if (!capabilities.documentHighlightProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector })
        });
    };
    DocumentHighlightFeature.prototype.registerLanguageProvider = function (options) {
        var client = this._client;
        var provideDocumentHighlights = function (document, position, token) {
            return client.sendRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDocumentHighlights, function (error) {
                client.logFailedRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, error);
                return Promise.resolve([]);
            });
        };
        var middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerDocumentHighlightProvider(options.documentSelector, {
            provideDocumentHighlights: function (document, position, token) {
                return middleware.provideDocumentHighlights
                    ? middleware.provideDocumentHighlights(document, position, token, provideDocumentHighlights)
                    : provideDocumentHighlights(document, position, token);
            }
        });
    };
    return DocumentHighlightFeature;
}(TextDocumentFeature));
var DocumentSymbolFeature = /** @class */ (function (_super) {
    __extends(DocumentSymbolFeature, _super);
    function DocumentSymbolFeature(client) {
        return _super.call(this, client, vscode_languageserver_protocol_1.DocumentSymbolRequest.type) || this;
    }
    DocumentSymbolFeature.prototype.fillClientCapabilities = function (capabilites) {
        var symbolCapabilities = ensure(ensure(capabilites, 'textDocument'), 'documentSymbol');
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
            valueSet: SupporedSymbolKinds
        };
        symbolCapabilities.hierarchicalDocumentSymbolSupport = true;
    };
    DocumentSymbolFeature.prototype.initialize = function (capabilities, documentSelector) {
        if (!capabilities.documentSymbolProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector })
        });
    };
    DocumentSymbolFeature.prototype.registerLanguageProvider = function (options) {
        var client = this._client;
        var provideDocumentSymbols = function (document, token) {
            return client.sendRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, client.code2ProtocolConverter.asDocumentSymbolParams(document), token).then(function (data) {
                if (data === null) {
                    return undefined;
                }
                if (data.length === 0) {
                    return [];
                }
                else {
                    var element = data[0];
                    if (vscode_languageserver_protocol_1.DocumentSymbol.is(element)) {
                        return client.protocol2CodeConverter.asDocumentSymbols(data);
                    }
                    else {
                        return client.protocol2CodeConverter.asSymbolInformations(data);
                    }
                }
            }, function (error) {
                client.logFailedRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, error);
                return Promise.resolve([]);
            });
        };
        var middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerDocumentSymbolProvider(options.documentSelector, {
            provideDocumentSymbols: function (document, token) {
                return middleware.provideDocumentSymbols
                    ? middleware.provideDocumentSymbols(document, token, provideDocumentSymbols)
                    : provideDocumentSymbols(document, token);
            }
        });
    };
    return DocumentSymbolFeature;
}(TextDocumentFeature));
var WorkspaceSymbolFeature = /** @class */ (function (_super) {
    __extends(WorkspaceSymbolFeature, _super);
    function WorkspaceSymbolFeature(client) {
        return _super.call(this, client, vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type) || this;
    }
    WorkspaceSymbolFeature.prototype.fillClientCapabilities = function (capabilites) {
        var symbolCapabilities = ensure(ensure(capabilites, 'workspace'), 'symbol');
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
            valueSet: SupporedSymbolKinds
        };
    };
    WorkspaceSymbolFeature.prototype.initialize = function (capabilities) {
        if (!capabilities.workspaceSymbolProvider) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: undefined
        });
    };
    WorkspaceSymbolFeature.prototype.registerLanguageProvider = function (_options) {
        var client = this._client;
        var provideWorkspaceSymbols = function (query, token) {
            return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, { query: query }, token).then(client.protocol2CodeConverter.asSymbolInformations, function (error) {
                client.logFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, error);
                return Promise.resolve([]);
            });
        };
        var middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerWorkspaceSymbolProvider({
            provideWorkspaceSymbols: function (query, token) {
                return middleware.provideWorkspaceSymbols
                    ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols)
                    : provideWorkspaceSymbols(query, token);
            }
        });
    };
    return WorkspaceSymbolFeature;
}(WorkspaceFeature));
var CodeActionFeature = /** @class */ (function (_super) {
    __extends(CodeActionFeature, _super);
    function CodeActionFeature(client) {
        return _super.call(this, client, vscode_languageserver_protocol_1.CodeActionRequest.type) || this;
    }
    CodeActionFeature.prototype.fillClientCapabilities = function (capabilites) {
        var cap = ensure(ensure(capabilites, 'textDocument'), 'codeAction');
        cap.dynamicRegistration = true;
        cap.codeActionLiteralSupport = {
            codeActionKind: {
                valueSet: [
                    '',
                    vscode_languageserver_protocol_1.CodeActionKind.QuickFix,
                    vscode_languageserver_protocol_1.CodeActionKind.Refactor,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorExtract,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorInline,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorRewrite,
                    vscode_languageserver_protocol_1.CodeActionKind.Source,
                    vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports
                ]
            }
        };
    };
    CodeActionFeature.prototype.initialize = function (capabilities, documentSelector) {
        if (!capabilities.codeActionProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector })
        });
    };
    CodeActionFeature.prototype.registerLanguageProvider = function (options) {
        var client = this._client;
        var provideCodeActions = function (document, range, context, token) {
            var params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                range: client.code2ProtocolConverter.asRange(range),
                context: client.code2ProtocolConverter.asCodeActionContext(context)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, params, token).then(function (values) {
                var e_7, _a;
                if (values === null) {
                    return undefined;
                }
                var result = [];
                try {
                    for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
                        var item = values_1_1.value;
                        if (vscode_languageserver_protocol_1.Command.is(item)) {
                            result.push(client.protocol2CodeConverter.asCommand(item));
                        }
                        else {
                            result.push(client.protocol2CodeConverter.asCodeAction(item));
                        }
                        ;
                    }
                }
                catch (e_7_1) { e_7 = { error: e_7_1 }; }
                finally {
                    try {
                        if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);
                    }
                    finally { if (e_7) throw e_7.error; }
                }
                return result;
            }, function (error) {
                client.logFailedRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, error);
                return Promise.resolve([]);
            });
        };
        var middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerCodeActionsProvider(options.documentSelector, {
            provideCodeActions: function (document, range, context, token) {
                return middleware.provideCodeActions
                    ? middleware.provideCodeActions(document, range, context, token, provideCodeActions)
                    : provideCodeActions(document, range, context, token);
            }
        });
    };
    return CodeActionFeature;
}(TextDocumentFeature));
var CodeLensFeature = /** @class */ (function (_super) {
    __extends(CodeLensFeature, _super);
    function CodeLensFeature(client) {
        return _super.call(this, client, vscode_languageserver_protocol_1.CodeLensRequest.type) || this;
    }
    CodeLensFeature.prototype.fillClientCapabilities = function (capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'codeLens').dynamicRegistration = true;
    };
    CodeLensFeature.prototype.initialize = function (capabilities, documentSelector) {
        if (!capabilities.codeLensProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector }, capabilities.codeLensProvider)
        });
    };
    CodeLensFeature.prototype.registerLanguageProvider = function (options) {
        var client = this._client;
        var provideCodeLenses = function (document, token) {
            return client.sendRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, client.code2ProtocolConverter.asCodeLensParams(document), token).then(client.protocol2CodeConverter.asCodeLenses, function (error) {
                client.logFailedRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, error);
                return Promise.resolve([]);
            });
        };
        var resolveCodeLens = function (codeLens, token) {
            return client.sendRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, client.code2ProtocolConverter.asCodeLens(codeLens), token).then(client.protocol2CodeConverter.asCodeLens, function (error) {
                client.logFailedRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, error);
                return codeLens;
            });
        };
        var middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerCodeLensProvider(options.documentSelector, {
            provideCodeLenses: function (document, token) {
                return middleware.provideCodeLenses
                    ? middleware.provideCodeLenses(document, token, provideCodeLenses)
                    : provideCodeLenses(document, token);
            },
            resolveCodeLens: (options.resolveProvider)
                ? function (codeLens, token) {
                    return middleware.resolveCodeLens
                        ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens)
                        : resolveCodeLens(codeLens, token);
                }
                : undefined
        });
    };
    return CodeLensFeature;
}(TextDocumentFeature));
var DocumentFormattingFeature = /** @class */ (function (_super) {
    __extends(DocumentFormattingFeature, _super);
    function DocumentFormattingFeature(client) {
        return _super.call(this, client, vscode_languageserver_protocol_1.DocumentFormattingRequest.type) || this;
    }
    DocumentFormattingFeature.prototype.fillClientCapabilities = function (capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'formatting').dynamicRegistration = true;
    };
    DocumentFormattingFeature.prototype.initialize = function (capabilities, documentSelector) {
        if (!capabilities.documentFormattingProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector })
        });
    };
    DocumentFormattingFeature.prototype.registerLanguageProvider = function (options) {
        var client = this._client;
        var provideDocumentFormattingEdits = function (document, options, token) {
            var params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                options: client.code2ProtocolConverter.asFormattingOptions(options)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, params, token).then(client.protocol2CodeConverter.asTextEdits, function (error) {
                client.logFailedRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, error);
                return Promise.resolve([]);
            });
        };
        var middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerDocumentFormattingEditProvider(options.documentSelector, {
            provideDocumentFormattingEdits: function (document, options, token) {
                return middleware.provideDocumentFormattingEdits
                    ? middleware.provideDocumentFormattingEdits(document, options, token, provideDocumentFormattingEdits)
                    : provideDocumentFormattingEdits(document, options, token);
            }
        });
    };
    return DocumentFormattingFeature;
}(TextDocumentFeature));
var DocumentRangeFormattingFeature = /** @class */ (function (_super) {
    __extends(DocumentRangeFormattingFeature, _super);
    function DocumentRangeFormattingFeature(client) {
        return _super.call(this, client, vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type) || this;
    }
    DocumentRangeFormattingFeature.prototype.fillClientCapabilities = function (capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'rangeFormatting').dynamicRegistration = true;
    };
    DocumentRangeFormattingFeature.prototype.initialize = function (capabilities, documentSelector) {
        if (!capabilities.documentRangeFormattingProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector })
        });
    };
    DocumentRangeFormattingFeature.prototype.registerLanguageProvider = function (options) {
        var client = this._client;
        var provideDocumentRangeFormattingEdits = function (document, range, options, token) {
            var params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                range: client.code2ProtocolConverter.asRange(range),
                options: client.code2ProtocolConverter.asFormattingOptions(options)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, params, token).then(client.protocol2CodeConverter.asTextEdits, function (error) {
                client.logFailedRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, error);
                return Promise.resolve([]);
            });
        };
        var middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerDocumentRangeFormattingEditProvider(options.documentSelector, {
            provideDocumentRangeFormattingEdits: function (document, range, options, token) {
                return middleware.provideDocumentRangeFormattingEdits
                    ? middleware.provideDocumentRangeFormattingEdits(document, range, options, token, provideDocumentRangeFormattingEdits)
                    : provideDocumentRangeFormattingEdits(document, range, options, token);
            }
        });
    };
    return DocumentRangeFormattingFeature;
}(TextDocumentFeature));
var DocumentOnTypeFormattingFeature = /** @class */ (function (_super) {
    __extends(DocumentOnTypeFormattingFeature, _super);
    function DocumentOnTypeFormattingFeature(client) {
        return _super.call(this, client, vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type) || this;
    }
    DocumentOnTypeFormattingFeature.prototype.fillClientCapabilities = function (capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'onTypeFormatting').dynamicRegistration = true;
    };
    DocumentOnTypeFormattingFeature.prototype.initialize = function (capabilities, documentSelector) {
        if (!capabilities.documentOnTypeFormattingProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector }, capabilities.documentOnTypeFormattingProvider)
        });
    };
    DocumentOnTypeFormattingFeature.prototype.registerLanguageProvider = function (options) {
        var client = this._client;
        var moreTriggerCharacter = options.moreTriggerCharacter || [];
        var provideOnTypeFormattingEdits = function (document, position, ch, options, token) {
            var params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                position: client.code2ProtocolConverter.asPosition(position),
                ch: ch,
                options: client.code2ProtocolConverter.asFormattingOptions(options)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, params, token).then(client.protocol2CodeConverter.asTextEdits, function (error) {
                client.logFailedRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, error);
                return Promise.resolve([]);
            });
        };
        var middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerOnTypeFormattingEditProvider.apply(vscode_1.languages, __spread([options.documentSelector, {
                provideOnTypeFormattingEdits: function (document, position, ch, options, token) {
                    return middleware.provideOnTypeFormattingEdits
                        ? middleware.provideOnTypeFormattingEdits(document, position, ch, options, token, provideOnTypeFormattingEdits)
                        : provideOnTypeFormattingEdits(document, position, ch, options, token);
                }
            }, options.firstTriggerCharacter], moreTriggerCharacter));
    };
    return DocumentOnTypeFormattingFeature;
}(TextDocumentFeature));
var RenameFeature = /** @class */ (function (_super) {
    __extends(RenameFeature, _super);
    function RenameFeature(client) {
        return _super.call(this, client, vscode_languageserver_protocol_1.RenameRequest.type) || this;
    }
    RenameFeature.prototype.fillClientCapabilities = function (capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'rename').dynamicRegistration = true;
    };
    RenameFeature.prototype.initialize = function (capabilities, documentSelector) {
        if (!capabilities.renameProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector })
        });
    };
    RenameFeature.prototype.registerLanguageProvider = function (options) {
        var client = this._client;
        var provideRenameEdits = function (document, position, newName, token) {
            var params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                position: client.code2ProtocolConverter.asPosition(position),
                newName: newName
            };
            return client.sendRequest(vscode_languageserver_protocol_1.RenameRequest.type, params, token).then(client.protocol2CodeConverter.asWorkspaceEdit, function (error) {
                client.logFailedRequest(vscode_languageserver_protocol_1.RenameRequest.type, error);
                return Promise.reject(new Error(error.message));
            });
        };
        var middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerRenameProvider(options.documentSelector, {
            provideRenameEdits: function (document, position, newName, token) {
                return middleware.provideRenameEdits
                    ? middleware.provideRenameEdits(document, position, newName, token, provideRenameEdits)
                    : provideRenameEdits(document, position, newName, token);
            }
        });
    };
    return RenameFeature;
}(TextDocumentFeature));
var DocumentLinkFeature = /** @class */ (function (_super) {
    __extends(DocumentLinkFeature, _super);
    function DocumentLinkFeature(client) {
        return _super.call(this, client, vscode_languageserver_protocol_1.DocumentLinkRequest.type) || this;
    }
    DocumentLinkFeature.prototype.fillClientCapabilities = function (capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'documentLink').dynamicRegistration = true;
    };
    DocumentLinkFeature.prototype.initialize = function (capabilities, documentSelector) {
        if (!capabilities.documentLinkProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector }, capabilities.documentLinkProvider)
        });
    };
    DocumentLinkFeature.prototype.registerLanguageProvider = function (options) {
        var client = this._client;
        var provideDocumentLinks = function (document, token) {
            return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, client.code2ProtocolConverter.asDocumentLinkParams(document), token).then(client.protocol2CodeConverter.asDocumentLinks, function (error) {
                client.logFailedRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, error);
                Promise.resolve(new Error(error.message));
            });
        };
        var resolveDocumentLink = function (link, token) {
            return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, client.code2ProtocolConverter.asDocumentLink(link), token).then(client.protocol2CodeConverter.asDocumentLink, function (error) {
                client.logFailedRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, error);
                Promise.resolve(new Error(error.message));
            });
        };
        var middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerDocumentLinkProvider(options.documentSelector, {
            provideDocumentLinks: function (document, token) {
                return middleware.provideDocumentLinks
                    ? middleware.provideDocumentLinks(document, token, provideDocumentLinks)
                    : provideDocumentLinks(document, token);
            },
            resolveDocumentLink: options.resolveProvider
                ? function (link, token) {
                    return middleware.resolveDocumentLink
                        ? middleware.resolveDocumentLink(link, token, resolveDocumentLink)
                        : resolveDocumentLink(link, token);
                }
                : undefined
        });
    };
    return DocumentLinkFeature;
}(TextDocumentFeature));
var ConfigurationFeature = /** @class */ (function () {
    function ConfigurationFeature(_client) {
        this._client = _client;
        this._listeners = new Map();
    }
    Object.defineProperty(ConfigurationFeature.prototype, "messages", {
        get: function () {
            return vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type;
        },
        enumerable: true,
        configurable: true
    });
    ConfigurationFeature.prototype.fillClientCapabilities = function (capabilities) {
        ensure(ensure(capabilities, 'workspace'), 'didChangeConfiguration').dynamicRegistration = true;
    };
    ConfigurationFeature.prototype.initialize = function () {
        var section = this._client.clientOptions.synchronize.configurationSection;
        if (section !== void 0) {
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: {
                    section: section
                }
            });
        }
    };
    ConfigurationFeature.prototype.register = function (_message, data) {
        var _this = this;
        var disposable = vscode_1.workspace.onDidChangeConfiguration(function (event) {
            _this.onDidChangeConfiguration(data.registerOptions.section, event);
        });
        this._listeners.set(data.id, disposable);
        if (data.registerOptions.section !== void 0) {
            this.onDidChangeConfiguration(data.registerOptions.section, undefined);
        }
    };
    ConfigurationFeature.prototype.unregister = function (id) {
        var disposable = this._listeners.get(id);
        if (disposable) {
            this._listeners.delete(id);
            disposable.dispose();
        }
    };
    ConfigurationFeature.prototype.dispose = function () {
        var e_8, _a;
        try {
            for (var _b = __values(this._listeners.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var disposable = _c.value;
                disposable.dispose();
            }
        }
        catch (e_8_1) { e_8 = { error: e_8_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_8) throw e_8.error; }
        }
        this._listeners.clear();
    };
    ConfigurationFeature.prototype.onDidChangeConfiguration = function (configurationSection, event) {
        var _this = this;
        var sections;
        if (Is.string(configurationSection)) {
            sections = [configurationSection];
        }
        else {
            sections = configurationSection;
        }
        if (sections !== void 0 && event !== void 0) {
            var affected = sections.some(function (section) { return event.affectsConfiguration(section); });
            if (!affected) {
                return;
            }
        }
        var didChangeConfiguration = function (sections) {
            if (sections === void 0) {
                _this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: null });
                return;
            }
            _this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: _this.extractSettingsInformation(sections) });
        };
        var middleware = this.getMiddleware();
        middleware
            ? middleware(sections, didChangeConfiguration)
            : didChangeConfiguration(sections);
    };
    ConfigurationFeature.prototype.extractSettingsInformation = function (keys) {
        function ensurePath(config, path) {
            var current = config;
            for (var i = 0; i < path.length - 1; i++) {
                var obj = current[path[i]];
                if (!obj) {
                    obj = Object.create(null);
                    current[path[i]] = obj;
                }
                current = obj;
            }
            return current;
        }
        var resource = this._client.clientOptions.workspaceFolder
            ? this._client.clientOptions.workspaceFolder.uri
            : undefined;
        var result = Object.create(null);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var index = key.indexOf('.');
            var config = null;
            if (index >= 0) {
                config = vscode_1.workspace.getConfiguration(key.substr(0, index), resource).get(key.substr(index + 1));
            }
            else {
                config = vscode_1.workspace.getConfiguration(key, resource);
            }
            if (config) {
                var path = keys[i].split('.');
                ensurePath(result, path)[path[path.length - 1]] = config;
            }
        }
        return result;
    };
    ConfigurationFeature.prototype.getMiddleware = function () {
        var middleware = this._client.clientOptions.middleware;
        if (middleware.workspace && middleware.workspace.didChangeConfiguration) {
            return middleware.workspace.didChangeConfiguration;
        }
        else {
            return undefined;
        }
    };
    return ConfigurationFeature;
}());
var ExecuteCommandFeature = /** @class */ (function () {
    function ExecuteCommandFeature(_client) {
        this._client = _client;
        this._commands = new Map();
    }
    Object.defineProperty(ExecuteCommandFeature.prototype, "messages", {
        get: function () {
            return vscode_languageserver_protocol_1.ExecuteCommandRequest.type;
        },
        enumerable: true,
        configurable: true
    });
    ExecuteCommandFeature.prototype.fillClientCapabilities = function (capabilities) {
        ensure(ensure(capabilities, 'workspace'), 'executeCommand').dynamicRegistration = true;
    };
    ExecuteCommandFeature.prototype.initialize = function (capabilities) {
        if (!capabilities.executeCommandProvider) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, capabilities.executeCommandProvider)
        });
    };
    ExecuteCommandFeature.prototype.register = function (_message, data) {
        var e_9, _a;
        var client = this._client;
        if (data.registerOptions.commands) {
            var disposeables = [];
            var _loop_2 = function (command) {
                disposeables.push(vscode_1.commands.registerCommand(command, function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    var params = {
                        command: command,
                        arguments: args
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params).then(undefined, function (error) {
                        client.logFailedRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, error);
                    });
                }));
            };
            try {
                for (var _b = __values(data.registerOptions.commands), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var command = _c.value;
                    _loop_2(command);
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_9) throw e_9.error; }
            }
            this._commands.set(data.id, disposeables);
        }
    };
    ExecuteCommandFeature.prototype.unregister = function (id) {
        var disposeables = this._commands.get(id);
        if (disposeables) {
            disposeables.forEach(function (disposable) { return disposable.dispose(); });
        }
    };
    ExecuteCommandFeature.prototype.dispose = function () {
        this._commands.forEach(function (value) {
            value.forEach(function (disposable) { return disposable.dispose(); });
        });
        this._commands.clear();
    };
    return ExecuteCommandFeature;
}());
var MessageTransports;
(function (MessageTransports) {
    function is(value) {
        var candidate = value;
        return candidate && vscode_languageserver_protocol_1.MessageReader.is(value.reader) && vscode_languageserver_protocol_1.MessageWriter.is(value.writer);
    }
    MessageTransports.is = is;
})(MessageTransports = exports.MessageTransports || (exports.MessageTransports = {}));
var BaseLanguageClient = /** @class */ (function () {
    function BaseLanguageClient(id, name, clientOptions) {
        var _this = this;
        this._features = [];
        this._method2Message = new Map();
        this._dynamicFeatures = new Map();
        this._id = id;
        this._name = name;
        clientOptions = clientOptions || {};
        this._clientOptions = {
            documentSelector: clientOptions.documentSelector || [],
            synchronize: clientOptions.synchronize || {},
            diagnosticCollectionName: clientOptions.diagnosticCollectionName,
            outputChannelName: clientOptions.outputChannelName || this._name,
            revealOutputChannelOn: clientOptions.revealOutputChannelOn || RevealOutputChannelOn.Error,
            stdioEncoding: clientOptions.stdioEncoding || 'utf8',
            initializationOptions: clientOptions.initializationOptions,
            initializationFailedHandler: clientOptions.initializationFailedHandler,
            errorHandler: clientOptions.errorHandler || new DefaultErrorHandler(this._name),
            middleware: clientOptions.middleware || {},
            uriConverters: clientOptions.uriConverters,
            workspaceFolder: clientOptions.workspaceFolder
        };
        this._clientOptions.synchronize = this._clientOptions.synchronize || {};
        this.state = ClientState.Initial;
        this._connectionPromise = undefined;
        this._resolvedConnection = undefined;
        this._initializeResult = undefined;
        if (clientOptions.outputChannel) {
            this._outputChannel = clientOptions.outputChannel;
            this._disposeOutputChannel = false;
        }
        else {
            this._outputChannel = undefined;
            this._disposeOutputChannel = true;
        }
        this._listeners = undefined;
        this._providers = undefined;
        this._diagnostics = undefined;
        this._fileEvents = [];
        this._fileEventDelayer = new async_1.Delayer(250);
        this._onReady = new Promise(function (resolve, reject) {
            _this._onReadyCallbacks = { resolve: resolve, reject: reject };
        });
        this._onStop = undefined;
        this._telemetryEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._stateChangeEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._tracer = {
            log: function (message, data) {
                _this.logTrace(message, data);
            }
        };
        this._c2p = c2p.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.code2Protocol : undefined);
        this._p2c = p2c.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.protocol2Code : undefined);
        this._syncedDocuments = new Map();
        this.registerBuiltinFeatures();
    }
    Object.defineProperty(BaseLanguageClient.prototype, "state", {
        get: function () {
            return this._state;
        },
        set: function (value) {
            var oldState = this.getPublicState();
            this._state = value;
            var newState = this.getPublicState();
            if (newState !== oldState) {
                this._stateChangeEmitter.fire({ oldState: oldState, newState: newState });
            }
        },
        enumerable: true,
        configurable: true
    });
    BaseLanguageClient.prototype.getPublicState = function () {
        if (this.state === ClientState.Running) {
            return State.Running;
        }
        else {
            return State.Stopped;
        }
    };
    Object.defineProperty(BaseLanguageClient.prototype, "initializeResult", {
        get: function () {
            return this._initializeResult;
        },
        enumerable: true,
        configurable: true
    });
    BaseLanguageClient.prototype.sendRequest = function (type) {
        var _a;
        var params = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            params[_i - 1] = arguments[_i];
        }
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        this.forceDocumentSync();
        try {
            return (_a = this._resolvedConnection).sendRequest.apply(_a, __spread([type], params));
        }
        catch (error) {
            this.error("Sending request " + (Is.string(type) ? type : type.method) + " failed.", error);
            throw error;
        }
    };
    BaseLanguageClient.prototype.onRequest = function (type, handler) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        try {
            this._resolvedConnection.onRequest(type, handler);
        }
        catch (error) {
            this.error("Registering request handler " + (Is.string(type) ? type : type.method) + " failed.", error);
            throw error;
        }
    };
    BaseLanguageClient.prototype.sendNotification = function (type, params) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        this.forceDocumentSync();
        try {
            this._resolvedConnection.sendNotification(type, params);
        }
        catch (error) {
            this.error("Sending notification " + (Is.string(type) ? type : type.method) + " failed.", error);
            throw error;
        }
    };
    BaseLanguageClient.prototype.onNotification = function (type, handler) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        try {
            this._resolvedConnection.onNotification(type, handler);
        }
        catch (error) {
            this.error("Registering notification handler " + (Is.string(type) ? type : type.method) + " failed.", error);
            throw error;
        }
    };
    Object.defineProperty(BaseLanguageClient.prototype, "clientOptions", {
        get: function () {
            return this._clientOptions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseLanguageClient.prototype, "protocol2CodeConverter", {
        get: function () {
            return this._p2c;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseLanguageClient.prototype, "code2ProtocolConverter", {
        get: function () {
            return this._c2p;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseLanguageClient.prototype, "onTelemetry", {
        get: function () {
            return this._telemetryEmitter.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseLanguageClient.prototype, "onDidChangeState", {
        get: function () {
            return this._stateChangeEmitter.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseLanguageClient.prototype, "outputChannel", {
        get: function () {
            if (!this._outputChannel) {
                this._outputChannel = vscode_1.window.createOutputChannel(this._clientOptions.outputChannelName ? this._clientOptions.outputChannelName : this._name);
            }
            return this._outputChannel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseLanguageClient.prototype, "diagnostics", {
        get: function () {
            return this._diagnostics;
        },
        enumerable: true,
        configurable: true
    });
    BaseLanguageClient.prototype.createDefaultErrorHandler = function () {
        return new DefaultErrorHandler(this._name);
    };
    Object.defineProperty(BaseLanguageClient.prototype, "trace", {
        set: function (value) {
            var _this = this;
            this._trace = value;
            this.onReady().then(function () {
                _this.resolveConnection().then(function (connection) {
                    connection.trace(value, _this._tracer);
                });
            }, function () {
            });
        },
        enumerable: true,
        configurable: true
    });
    BaseLanguageClient.prototype.data2String = function (data) {
        if (data instanceof vscode_languageserver_protocol_1.ResponseError) {
            var responseError = data;
            return "  Message: " + responseError.message + "\n  Code: " + responseError.code + " " + (responseError.data ? '\n' + responseError.data.toString() : '');
        }
        if (data instanceof Error) {
            if (Is.string(data.stack)) {
                return data.stack;
            }
            return data.message;
        }
        if (Is.string(data)) {
            return data;
        }
        return data.toString();
    };
    BaseLanguageClient.prototype.info = function (message, data) {
        this.outputChannel.appendLine("[Info  - " + (new Date().toLocaleTimeString()) + "] " + message);
        if (data) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Info) {
            this.outputChannel.show(true);
        }
    };
    BaseLanguageClient.prototype.warn = function (message, data) {
        this.outputChannel.appendLine("[Warn  - " + (new Date().toLocaleTimeString()) + "] " + message);
        if (data) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Warn) {
            this.outputChannel.show(true);
        }
    };
    BaseLanguageClient.prototype.error = function (message, data) {
        this.outputChannel.appendLine("[Error - " + (new Date().toLocaleTimeString()) + "] " + message);
        if (data) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Error) {
            this.outputChannel.show(true);
        }
    };
    BaseLanguageClient.prototype.logTrace = function (message, data) {
        this.outputChannel.appendLine("[Trace - " + (new Date().toLocaleTimeString()) + "] " + message);
        if (data) {
            this.outputChannel.appendLine(this.data2String(data));
        }
    };
    BaseLanguageClient.prototype.needsStart = function () {
        return this.state === ClientState.Initial || this.state === ClientState.Stopping || this.state === ClientState.Stopped;
    };
    BaseLanguageClient.prototype.needsStop = function () {
        return this.state === ClientState.Starting || this.state === ClientState.Running;
    };
    BaseLanguageClient.prototype.onReady = function () {
        return this._onReady;
    };
    BaseLanguageClient.prototype.isConnectionActive = function () {
        return this.state === ClientState.Running && !!this._resolvedConnection;
    };
    BaseLanguageClient.prototype.start = function () {
        var _this = this;
        this._listeners = [];
        this._providers = [];
        // If we restart then the diagnostics collection is reused.
        if (!this._diagnostics) {
            this._diagnostics = this._clientOptions.diagnosticCollectionName
                ? vscode_1.languages.createDiagnosticCollection(this._clientOptions.diagnosticCollectionName)
                : vscode_1.languages.createDiagnosticCollection();
        }
        this.state = ClientState.Starting;
        this.resolveConnection().then(function (connection) {
            connection.onLogMessage(function (message) {
                switch (message.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        _this.error(message.message);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        _this.warn(message.message);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        _this.info(message.message);
                        break;
                    default:
                        _this.outputChannel.appendLine(message.message);
                }
            });
            connection.onShowMessage(function (message) {
                switch (message.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        vscode_1.window.showErrorMessage(message.message);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        vscode_1.window.showWarningMessage(message.message);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        vscode_1.window.showInformationMessage(message.message);
                        break;
                    default:
                        vscode_1.window.showInformationMessage(message.message);
                }
            });
            connection.onRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, function (params) {
                var messageFunc;
                switch (params.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        messageFunc = vscode_1.window.showErrorMessage;
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        messageFunc = vscode_1.window.showWarningMessage;
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        messageFunc = vscode_1.window.showInformationMessage;
                        break;
                    default:
                        messageFunc = vscode_1.window.showInformationMessage;
                }
                var actions = params.actions || [];
                return messageFunc.apply(void 0, __spread([params.message], actions));
            });
            connection.onTelemetry(function (data) {
                _this._telemetryEmitter.fire(data);
            });
            connection.listen();
            // Error is handled in the intialize call.
            return _this.initialize(connection);
        }).then(undefined, function (error) {
            _this.state = ClientState.StartFailed;
            _this._onReadyCallbacks.reject(error);
            _this.error('Starting client failed', error);
            vscode_1.window.showErrorMessage("Couldn't start client " + _this._name);
        });
        return new vscode_1.Disposable(function () {
            if (_this.needsStop()) {
                _this.stop();
            }
        });
    };
    BaseLanguageClient.prototype.resolveConnection = function () {
        if (!this._connectionPromise) {
            this._connectionPromise = this.createConnection();
        }
        return this._connectionPromise;
    };
    BaseLanguageClient.prototype.initialize = function (connection) {
        var _this = this;
        this.refreshTrace(connection, false);
        var initOption = this._clientOptions.initializationOptions;
        var rootPath = this._clientOptions.workspaceFolder
            ? this._clientOptions.workspaceFolder.uri.fsPath
            : this._clientGetRootPath();
        var initParams = {
            processId: process.pid,
            rootPath: rootPath ? rootPath : null,
            rootUri: rootPath ? this._c2p.asUri(vscode_1.Uri.file(rootPath)) : null,
            capabilities: this.computeClientCapabilities(),
            initializationOptions: Is.func(initOption) ? initOption() : initOption,
            trace: vscode_languageserver_protocol_1.Trace.toString(this._trace),
            workspaceFolders: null
        };
        this.fillInitializeParams(initParams);
        return connection.initialize(initParams).then(function (result) {
            _this._resolvedConnection = connection;
            _this._initializeResult = result;
            _this.state = ClientState.Running;
            var textDocumentSyncOptions = undefined;
            if (Is.number(result.capabilities.textDocumentSync) && result.capabilities.textDocumentSync !== vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
                textDocumentSyncOptions = {
                    openClose: true,
                    change: result.capabilities.textDocumentSync,
                    save: {
                        includeText: false
                    }
                };
            }
            else if (result.capabilities.textDocumentSync !== void 0 && result.capabilities.textDocumentSync !== null) {
                textDocumentSyncOptions = result.capabilities.textDocumentSync;
            }
            _this._capabilities = Object.assign({}, result.capabilities, { resolvedTextDocumentSync: textDocumentSyncOptions });
            connection.onDiagnostics(function (params) { return _this.handleDiagnostics(params); });
            connection.onRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, function (params) { return _this.handleRegistrationRequest(params); });
            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199
            connection.onRequest('client/registerFeature', function (params) { return _this.handleRegistrationRequest(params); });
            connection.onRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, function (params) { return _this.handleUnregistrationRequest(params); });
            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199
            connection.onRequest('client/unregisterFeature', function (params) { return _this.handleUnregistrationRequest(params); });
            connection.onRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, function (params) { return _this.handleApplyWorkspaceEdit(params); });
            connection.sendNotification(vscode_languageserver_protocol_1.InitializedNotification.type, {});
            _this.hookFileEvents(connection);
            _this.hookConfigurationChanged(connection);
            _this.initializeFeatures(connection);
            _this._onReadyCallbacks.resolve();
            return result;
        }).then(undefined, function (error) {
            if (_this._clientOptions.initializationFailedHandler) {
                if (_this._clientOptions.initializationFailedHandler(error)) {
                    _this.initialize(connection);
                }
                else {
                    _this.stop();
                    _this._onReadyCallbacks.reject(error);
                }
            }
            else if (error instanceof vscode_languageserver_protocol_1.ResponseError && error.data && error.data.retry) {
                vscode_1.window.showErrorMessage(error.message, { title: 'Retry', id: "retry" }).then(function (item) {
                    if (item && item.id === 'retry') {
                        _this.initialize(connection);
                    }
                    else {
                        _this.stop();
                        _this._onReadyCallbacks.reject(error);
                    }
                });
            }
            else {
                if (error && error.message) {
                    vscode_1.window.showErrorMessage(error.message);
                }
                _this.error('Server initialization failed.', error);
                _this.stop();
                _this._onReadyCallbacks.reject(error);
            }
        });
    };
    BaseLanguageClient.prototype._clientGetRootPath = function () {
        var folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
            return undefined;
        }
        var folder = folders[0];
        if (folder.uri.scheme === 'file') {
            return folder.uri.fsPath;
        }
        return undefined;
    };
    BaseLanguageClient.prototype.stop = function () {
        var _this = this;
        this._initializeResult = undefined;
        if (!this._connectionPromise) {
            this.state = ClientState.Stopped;
            return Promise.resolve();
        }
        if (this.state === ClientState.Stopping && this._onStop) {
            return this._onStop;
        }
        this.state = ClientState.Stopping;
        this.cleanUp();
        // unkook listeners
        return this._onStop = this.resolveConnection().then(function (connection) {
            return connection.shutdown().then(function () {
                connection.exit();
                connection.dispose();
                _this.state = ClientState.Stopped;
                _this._onStop = undefined;
                _this._connectionPromise = undefined;
                _this._resolvedConnection = undefined;
            });
        });
    };
    BaseLanguageClient.prototype.cleanUp = function (channel, diagnostics) {
        var e_10, _a;
        if (channel === void 0) { channel = true; }
        if (diagnostics === void 0) { diagnostics = true; }
        if (this._listeners) {
            this._listeners.forEach(function (listener) { return listener.dispose(); });
            this._listeners = undefined;
        }
        if (this._providers) {
            this._providers.forEach(function (provider) { return provider.dispose(); });
            this._providers = undefined;
        }
        if (this._syncedDocuments) {
            this._syncedDocuments.clear();
        }
        try {
            for (var _b = __values(this._dynamicFeatures.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var handler = _c.value;
                handler.dispose();
            }
        }
        catch (e_10_1) { e_10 = { error: e_10_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_10) throw e_10.error; }
        }
        if (channel && this._outputChannel && this._disposeOutputChannel) {
            this._outputChannel.dispose();
            this._outputChannel = undefined;
        }
        if (diagnostics && this._diagnostics) {
            this._diagnostics.dispose();
            this._diagnostics = undefined;
        }
    };
    BaseLanguageClient.prototype.notifyFileEvent = function (event) {
        var _this = this;
        this._fileEvents.push(event);
        this._fileEventDelayer.trigger(function () {
            _this.onReady().then(function () {
                _this.resolveConnection().then(function (connection) {
                    if (_this.isConnectionActive()) {
                        connection.didChangeWatchedFiles({ changes: _this._fileEvents });
                    }
                    _this._fileEvents = [];
                });
            }, function (error) {
                _this.error("Notify file events failed.", error);
            });
        });
    };
    BaseLanguageClient.prototype.forceDocumentSync = function () {
        this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type.method).forceDelivery();
    };
    BaseLanguageClient.prototype.handleDiagnostics = function (params) {
        var _this = this;
        if (!this._diagnostics) {
            return;
        }
        var uri = this._p2c.asUri(params.uri);
        var diagnostics = this._p2c.asDiagnostics(params.diagnostics);
        var middleware = this.clientOptions.middleware.handleDiagnostics;
        if (middleware) {
            middleware(uri, diagnostics, function (uri, diagnostics) { return _this.setDiagnostics(uri, diagnostics); });
        }
        else {
            this.setDiagnostics(uri, diagnostics);
        }
    };
    BaseLanguageClient.prototype.setDiagnostics = function (uri, diagnostics) {
        if (!this._diagnostics) {
            return;
        }
        this._diagnostics.set(uri, diagnostics);
    };
    BaseLanguageClient.prototype.createConnection = function () {
        var _this = this;
        var errorHandler = function (error, message, count) {
            _this.handleConnectionError(error, message, count);
        };
        var closeHandler = function () {
            _this.handleConnectionClosed();
        };
        return this.createMessageTransports(this._clientOptions.stdioEncoding || 'utf8').then(function (transports) {
            return createConnection(transports.reader, transports.writer, errorHandler, closeHandler);
        });
    };
    BaseLanguageClient.prototype.handleConnectionClosed = function () {
        // Check whether this is a normal shutdown in progress or the client stopped normally.
        if (this.state === ClientState.Stopping || this.state === ClientState.Stopped) {
            return;
        }
        try {
            if (this._resolvedConnection) {
                this._resolvedConnection.dispose();
            }
        }
        catch (error) {
            // Disposing a connection could fail if error cases.
        }
        var action = CloseAction.DoNotRestart;
        try {
            action = this._clientOptions.errorHandler.closed();
        }
        catch (error) {
            // Ignore errors coming from the error handler.
        }
        this._connectionPromise = undefined;
        this._resolvedConnection = undefined;
        if (action === CloseAction.DoNotRestart) {
            this.error('Connection to server got closed. Server will not be restarted.');
            this.state = ClientState.Stopped;
            this.cleanUp(false, true);
        }
        else if (action === CloseAction.Restart) {
            this.info('Connection to server got closed. Server will restart.');
            this.cleanUp(false, false);
            this.state = ClientState.Initial;
            this.start();
        }
    };
    BaseLanguageClient.prototype.handleConnectionError = function (error, message, count) {
        var action = this._clientOptions.errorHandler.error(error, message, count);
        if (action === ErrorAction.Shutdown) {
            this.error('Connection to server is erroring. Shutting down server.');
            this.stop();
        }
    };
    BaseLanguageClient.prototype.hookConfigurationChanged = function (connection) {
        var _this = this;
        vscode_1.workspace.onDidChangeConfiguration(function () {
            _this.refreshTrace(connection, true);
        });
    };
    BaseLanguageClient.prototype.refreshTrace = function (connection, sendNotification) {
        if (sendNotification === void 0) { sendNotification = false; }
        var config = vscode_1.workspace.getConfiguration(this._id);
        var trace = vscode_languageserver_protocol_1.Trace.Off;
        if (config) {
            trace = vscode_languageserver_protocol_1.Trace.fromString(config.get('trace.server', 'off'));
        }
        this._trace = trace;
        connection.trace(this._trace, this._tracer, sendNotification);
    };
    BaseLanguageClient.prototype.hookFileEvents = function (_connection) {
        var fileEvents = this._clientOptions.synchronize.fileEvents;
        if (!fileEvents) {
            return;
        }
        var watchers;
        if (Is.array(fileEvents)) {
            watchers = fileEvents;
        }
        else {
            watchers = [fileEvents];
        }
        if (!watchers) {
            return;
        }
        this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type.method).registerRaw(UUID.generateUuid(), watchers);
    };
    BaseLanguageClient.prototype.registerFeatures = function (features) {
        var e_11, _a;
        try {
            for (var features_1 = __values(features), features_1_1 = features_1.next(); !features_1_1.done; features_1_1 = features_1.next()) {
                var feature = features_1_1.value;
                this.registerFeature(feature);
            }
        }
        catch (e_11_1) { e_11 = { error: e_11_1 }; }
        finally {
            try {
                if (features_1_1 && !features_1_1.done && (_a = features_1.return)) _a.call(features_1);
            }
            finally { if (e_11) throw e_11.error; }
        }
    };
    BaseLanguageClient.prototype.registerFeature = function (feature) {
        var e_12, _a;
        this._features.push(feature);
        if (DynamicFeature.is(feature)) {
            var messages = feature.messages;
            if (Array.isArray(messages)) {
                try {
                    for (var messages_1 = __values(messages), messages_1_1 = messages_1.next(); !messages_1_1.done; messages_1_1 = messages_1.next()) {
                        var message = messages_1_1.value;
                        this._method2Message.set(message.method, message);
                        this._dynamicFeatures.set(message.method, feature);
                    }
                }
                catch (e_12_1) { e_12 = { error: e_12_1 }; }
                finally {
                    try {
                        if (messages_1_1 && !messages_1_1.done && (_a = messages_1.return)) _a.call(messages_1);
                    }
                    finally { if (e_12) throw e_12.error; }
                }
            }
            else {
                this._method2Message.set(messages.method, messages);
                this._dynamicFeatures.set(messages.method, feature);
            }
        }
    };
    BaseLanguageClient.prototype.registerBuiltinFeatures = function () {
        var _this = this;
        this.registerFeature(new ConfigurationFeature(this));
        this.registerFeature(new DidOpenTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new DidChangeTextDocumentFeature(this));
        this.registerFeature(new WillSaveFeature(this));
        this.registerFeature(new WillSaveWaitUntilFeature(this));
        this.registerFeature(new DidSaveTextDocumentFeature(this));
        this.registerFeature(new DidCloseTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new FileSystemWatcherFeature(this, function (event) { return _this.notifyFileEvent(event); }));
        this.registerFeature(new CompletionItemFeature(this));
        this.registerFeature(new HoverFeature(this));
        this.registerFeature(new SignatureHelpFeature(this));
        this.registerFeature(new DefinitionFeature(this));
        this.registerFeature(new ReferencesFeature(this));
        this.registerFeature(new DocumentHighlightFeature(this));
        this.registerFeature(new DocumentSymbolFeature(this));
        this.registerFeature(new WorkspaceSymbolFeature(this));
        this.registerFeature(new CodeActionFeature(this));
        this.registerFeature(new CodeLensFeature(this));
        this.registerFeature(new DocumentFormattingFeature(this));
        this.registerFeature(new DocumentRangeFormattingFeature(this));
        this.registerFeature(new DocumentOnTypeFormattingFeature(this));
        this.registerFeature(new RenameFeature(this));
        this.registerFeature(new DocumentLinkFeature(this));
        this.registerFeature(new ExecuteCommandFeature(this));
    };
    BaseLanguageClient.prototype.fillInitializeParams = function (params) {
        var e_13, _a;
        try {
            for (var _b = __values(this._features), _c = _b.next(); !_c.done; _c = _b.next()) {
                var feature = _c.value;
                if (Is.func(feature.fillInitializeParams)) {
                    feature.fillInitializeParams(params);
                }
            }
        }
        catch (e_13_1) { e_13 = { error: e_13_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_13) throw e_13.error; }
        }
    };
    BaseLanguageClient.prototype.computeClientCapabilities = function () {
        var e_14, _a;
        var result = {};
        ensure(result, 'workspace').applyEdit = true;
        ensure(ensure(result, 'workspace'), 'workspaceEdit').documentChanges = true;
        ensure(ensure(result, 'textDocument'), 'publishDiagnostics').relatedInformation = true;
        try {
            for (var _b = __values(this._features), _c = _b.next(); !_c.done; _c = _b.next()) {
                var feature = _c.value;
                feature.fillClientCapabilities(result);
            }
        }
        catch (e_14_1) { e_14 = { error: e_14_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_14) throw e_14.error; }
        }
        return result;
    };
    BaseLanguageClient.prototype.initializeFeatures = function (_connection) {
        var e_15, _a;
        var documentSelector = this._clientOptions.documentSelector;
        try {
            for (var _b = __values(this._features), _c = _b.next(); !_c.done; _c = _b.next()) {
                var feature = _c.value;
                feature.initialize(this._capabilities, documentSelector);
            }
        }
        catch (e_15_1) { e_15 = { error: e_15_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_15) throw e_15.error; }
        }
    };
    BaseLanguageClient.prototype.handleRegistrationRequest = function (params) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var e_16, _a;
            try {
                for (var _b = __values(params.registrations), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var registration = _c.value;
                    var feature = _this._dynamicFeatures.get(registration.method);
                    if (!feature) {
                        reject(new Error("No feature implementation for " + registration.method + " found. Registration failed."));
                        return;
                    }
                    var options = registration.registerOptions || {};
                    options.documentSelector = options.documentSelector || _this._clientOptions.documentSelector;
                    var data = {
                        id: registration.id,
                        registerOptions: options
                    };
                    feature.register(_this._method2Message.get(registration.method), data);
                }
            }
            catch (e_16_1) { e_16 = { error: e_16_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_16) throw e_16.error; }
            }
            resolve();
        });
    };
    BaseLanguageClient.prototype.handleUnregistrationRequest = function (params) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var e_17, _a;
            try {
                for (var _b = __values(params.unregisterations), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var unregistration = _c.value;
                    var feature = _this._dynamicFeatures.get(unregistration.method);
                    if (!feature) {
                        reject(new Error("No feature implementation for " + unregistration.method + " found. Unregistration failed."));
                        return;
                    }
                    feature.unregister(unregistration.id);
                }
            }
            catch (e_17_1) { e_17 = { error: e_17_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_17) throw e_17.error; }
            }
            ;
            resolve();
        });
    };
    BaseLanguageClient.prototype.handleApplyWorkspaceEdit = function (params) {
        var e_18, _a;
        // This is some sort of workaround since the version check should be done by VS Code in the Workspace.applyEdit.
        // However doing it here adds some safety since the server can lag more behind then an extension.
        var workspaceEdit = params.edit;
        var openTextDocuments = new Map();
        vscode_1.workspace.textDocuments.forEach(function (document) { return openTextDocuments.set(document.uri.toString(), document); });
        var versionMismatch = false;
        if (workspaceEdit.documentChanges) {
            try {
                for (var _b = __values(workspaceEdit.documentChanges), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var change = _c.value;
                    if (change.textDocument.version && change.textDocument.version >= 0) {
                        var textDocument = openTextDocuments.get(change.textDocument.uri);
                        if (textDocument && textDocument.version !== change.textDocument.version) {
                            versionMismatch = true;
                            break;
                        }
                    }
                }
            }
            catch (e_18_1) { e_18 = { error: e_18_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_18) throw e_18.error; }
            }
        }
        if (versionMismatch) {
            return Promise.resolve({ applied: false });
        }
        return vscode_1.workspace.applyEdit(this._p2c.asWorkspaceEdit(params.edit)).then(function (value) { return { applied: value }; });
    };
    ;
    BaseLanguageClient.prototype.logFailedRequest = function (type, error) {
        // If we get a request cancel don't log anything.
        if (error instanceof vscode_languageserver_protocol_1.ResponseError && error.code === vscode_languageserver_protocol_1.ErrorCodes.RequestCancelled) {
            return;
        }
        this.error("Request " + type.method + " failed.", error);
    };
    return BaseLanguageClient;
}());
exports.BaseLanguageClient = BaseLanguageClient;
