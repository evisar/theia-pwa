import { Action } from "../base/actions/action";
import { ActionHandlerRegistry, IActionHandler } from "../base/actions/action-handler";
import { IActionDispatcher } from "../base/actions/action-dispatcher";
import { ViewerOptions } from "../base/views/viewer-options";
import { ICommand } from "../base/commands/command";
/**
 * A model source is serving the model to the event cycle. It represents
 * the entry point to the client for external sources, such as model
 * editors.
 *
 * As an IActionHandler it listens to actions in and reacts to them with
 * commands or actions if necessary. This way, you can implement action
 * protocols between the client and the outside world.
 *
 * There are two default implementations for a ModelSource:
 * <ul>
 * <li>the LocalModelSource handles the actions to calculate bounds and
 * set/update the model</li>
 * <li>the DiagramServer connects via websocket to a remote source. It
 * can be used to connect to a model editor that provides the model,
 * layouts diagrams, transfers selection and answers model queries from
 * the client.</li>
 */
export declare abstract class ModelSource implements IActionHandler {
    readonly actionDispatcher: IActionDispatcher;
    protected viewerOptions: ViewerOptions;
    constructor(actionDispatcher: IActionDispatcher, actionHandlerRegistry: ActionHandlerRegistry, viewerOptions: ViewerOptions);
    protected initialize(registry: ActionHandlerRegistry): void;
    abstract handle(action: Action): ICommand | Action | void;
}
//# sourceMappingURL=model-source.d.ts.map