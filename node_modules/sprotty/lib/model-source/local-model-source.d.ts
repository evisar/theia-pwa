import { Bounds, Point } from "../utils/geometry";
import { Deferred } from "../utils/async";
import { ILogger } from "../utils/logging";
import { Action } from "../base/actions/action";
import { ActionHandlerRegistry } from "../base/actions/action-handler";
import { IActionDispatcher } from "../base/actions/action-dispatcher";
import { ViewerOptions } from "../base/views/viewer-options";
import { RequestModelAction } from "../base/features/set-model";
import { SModelElementSchema, SModelIndex, SModelRootSchema } from "../base/model/smodel";
import { ComputedBoundsAction } from '../features/bounds/bounds-manipulation';
import { Match } from "../features/update/model-matching";
import { RequestPopupModelAction } from "../features/hover/hover";
import { ModelSource } from "./model-source";
import { ExportSvgAction } from '../features/export/svg-exporter';
import { CollapseExpandAction, CollapseExpandAllAction } from '../features/expand/expand';
import { DiagramState } from './diagram-state';
/**
 * A model source that allows to set and modify the model through function calls.
 * This class can be used as a facade over the action-based API of sprotty. It handles
 * actions for bounds calculation and model updates.
 */
export declare class LocalModelSource extends ModelSource {
    protected readonly logger: ILogger;
    protected modelProvider?: IStateAwareModelProvider | undefined;
    protected popupModelProvider?: IPopupModelProvider | undefined;
    protected layoutEngine?: IModelLayoutEngine | undefined;
    protected currentRoot: SModelRootSchema;
    protected diagramState: DiagramState;
    /**
     * The `type` property of the model root is used to determine whether a model update
     * is a change of the previous model or a totally new one.
     */
    protected lastSubmittedModelType: string;
    /**
     * When client layout is active, model updates are not applied immediately. Instead the
     * model is rendered on a hidden canvas first to derive actual bounds. The promises listed
     * here are resolved after the new bounds have been applied and the new model state has
     * been actually applied to the visible canvas.
     */
    protected pendingUpdates: Deferred<void>[];
    model: SModelRootSchema;
    constructor(actionDispatcher: IActionDispatcher, actionHandlerRegistry: ActionHandlerRegistry, viewerOptions: ViewerOptions, logger: ILogger, modelProvider?: IStateAwareModelProvider | undefined, popupModelProvider?: IPopupModelProvider | undefined, layoutEngine?: IModelLayoutEngine | undefined);
    protected initialize(registry: ActionHandlerRegistry): void;
    /**
     * Set the model without incremental update.
     */
    setModel(newRoot: SModelRootSchema): Promise<void>;
    /**
     * Apply an incremental update to the model with an animation showing the transition to
     * the new state. If `newRoot` is undefined, the current root is submitted; in that case
     * it is assumed that it has been modified before.
     */
    updateModel(newRoot?: SModelRootSchema): Promise<void>;
    /**
     * If client layout is active, run a `RequestBoundsAction` and wait for the resulting
     * `ComputedBoundsAction`, otherwise call `doSubmitModel(â€¦)` directly.
     */
    protected submitModel(newRoot: SModelRootSchema, update: boolean | Match[]): Promise<void>;
    /**
     * Submit the given model with an `UpdateModelAction` or a `SetModelAction` depending on the
     * `update` argument. If available, the model layout engine is invoked first.
     */
    protected doSubmitModel(newRoot: SModelRootSchema, update: boolean | Match[], index?: SModelIndex<SModelElementSchema>): Promise<void>;
    /**
     * Modify the current model with an array of matches.
     */
    applyMatches(matches: Match[]): Promise<void>;
    /**
     * Modify the current model by adding new elements.
     */
    addElements(elements: (SModelElementSchema | {
        element: SModelElementSchema;
        parentId: string;
    })[]): Promise<void>;
    /**
     * Modify the current model by removing elements.
     */
    removeElements(elements: (string | {
        elementId: string;
        parentId: string;
    })[]): Promise<void>;
    handle(action: Action): void;
    protected handleRequestModel(action: RequestModelAction): void;
    protected handleComputedBounds(action: ComputedBoundsAction): void;
    protected applyBounds(element: SModelElementSchema, newBounds: Bounds): void;
    protected applyAlignment(element: SModelElementSchema, newAlignment: Point): void;
    protected handleRequestPopupModel(action: RequestPopupModelAction): void;
    protected handleExportSvgAction(action: ExportSvgAction): void;
    protected handleCollapseExpandAction(action: CollapseExpandAction): void;
    protected handleCollapseExpandAllAction(action: CollapseExpandAllAction): void;
}
/**
 * @deprecated Use IPopupModelProvider instead.
 */
export declare type PopupModelFactory = (request: RequestPopupModelAction, element?: SModelElementSchema) => SModelRootSchema | undefined;
export interface IPopupModelProvider {
    getPopupModel(request: RequestPopupModelAction, element?: SModelElementSchema): SModelRootSchema | undefined;
}
export interface IStateAwareModelProvider {
    getModel(diagramState: DiagramState, currentRoot?: SModelRootSchema): SModelRootSchema;
}
export interface IModelLayoutEngine {
    layout(model: SModelRootSchema, index?: SModelIndex<SModelElementSchema>): SModelRootSchema | Promise<SModelRootSchema>;
}
//# sourceMappingURL=local-model-source.d.ts.map