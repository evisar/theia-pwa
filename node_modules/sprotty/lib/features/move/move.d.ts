import { Point } from '../../utils/geometry';
import { VNode } from "snabbdom/vnode";
import { SModelElement, SModelIndex, SModelRoot } from "../../base/model/smodel";
import { Action } from "../../base/actions/action";
import { ICommand, CommandExecutionContext, MergeableCommand } from "../../base/commands/command";
import { Animation } from "../../base/animations/animation";
import { MouseListener } from "../../base/views/mouse-tool";
import { IVNodeDecorator } from "../../base/views/vnode-decorators";
import { Routable, SRoutingHandle } from '../edit/model';
import { Locateable } from './model';
export declare class MoveAction implements Action {
    readonly moves: ElementMove[];
    readonly animate: boolean;
    kind: string;
    constructor(moves: ElementMove[], animate?: boolean);
}
export interface ElementMove {
    elementId: string;
    fromPosition?: Point;
    toPosition: Point;
}
export interface ResolvedElementMove {
    elementId: string;
    element: SModelElement & Locateable;
    fromPosition: Point;
    toPosition: Point;
}
export interface ResolvedElementRoute {
    elementId: string;
    element: SModelElement & Routable;
    fromRoute: Point[];
    toRoute: Point[];
}
export declare class MoveCommand extends MergeableCommand {
    protected action: MoveAction;
    static readonly KIND: string;
    resolvedMoves: Map<string, ResolvedElementMove>;
    resolvedRoutes: Map<string, ResolvedElementRoute>;
    constructor(action: MoveAction);
    execute(context: CommandExecutionContext): import("../../base/commands/command").CommandResult;
    protected resolve(move: ElementMove, index: SModelIndex<SModelElement>): ResolvedElementMove | undefined;
    protected handleAttachedElement(element: SModelElement): void;
    protected doMove(context: CommandExecutionContext, reverse?: boolean): SModelRoot;
    undo(context: CommandExecutionContext): Promise<SModelRoot>;
    redo(context: CommandExecutionContext): Promise<SModelRoot>;
    merge(command: ICommand, context: CommandExecutionContext): boolean;
}
export declare class MoveAnimation extends Animation {
    protected model: SModelRoot;
    elementMoves: Map<string, ResolvedElementMove>;
    elementRoutes: Map<string, ResolvedElementRoute>;
    protected reverse: boolean;
    constructor(model: SModelRoot, elementMoves: Map<string, ResolvedElementMove>, elementRoutes: Map<string, ResolvedElementRoute>, context: CommandExecutionContext, reverse?: boolean);
    tween(t: number): SModelRoot;
}
export declare class MoveMouseListener extends MouseListener {
    hasDragged: boolean;
    lastDragPosition: Point | undefined;
    mouseDown(target: SModelElement, event: MouseEvent): Action[];
    mouseMove(target: SModelElement, event: MouseEvent): Action[];
    protected getHandlePosition(handle: SRoutingHandle): Point | undefined;
    mouseEnter(target: SModelElement, event: MouseEvent): Action[];
    mouseUp(target: SModelElement, event: MouseEvent): Action[];
    decorate(vnode: VNode, element: SModelElement): VNode;
}
export declare class LocationDecorator implements IVNodeDecorator {
    decorate(vnode: VNode, element: SModelElement): VNode;
    postUpdate(): void;
}
//# sourceMappingURL=move.d.ts.map