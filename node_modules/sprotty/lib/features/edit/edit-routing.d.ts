import { Point } from "../../utils/geometry";
import { Routable, SRoutingHandle } from './model';
import { Action } from "../../base/actions/action";
import { Command, CommandExecutionContext, CommandResult } from "../../base/commands/command";
import { SModelElement, SModelRoot, SParentElement, SModelIndex } from '../../base/model/smodel';
import { Animation } from '../../base/animations/animation';
export declare function createRoutingHandle(kind: 'junction' | 'line', parentId: string, index: number): SRoutingHandle;
export declare function createRoutingHandles(editTarget: SParentElement & Routable): void;
export declare class SwitchEditModeAction implements Action {
    readonly elementsToActivate: string[];
    readonly elementsToDeactivate: string[];
    kind: string;
    constructor(elementsToActivate?: string[], elementsToDeactivate?: string[]);
}
export declare class SwitchEditModeCommand extends Command {
    action: SwitchEditModeAction;
    static KIND: string;
    protected elementsToActivate: SModelElement[];
    protected elementsToDeactivate: SModelElement[];
    protected handlesToRemove: {
        handle: SRoutingHandle;
        parent: SParentElement & Routable;
        point?: Point;
    }[];
    constructor(action: SwitchEditModeAction);
    execute(context: CommandExecutionContext): SModelRoot;
    protected doExecute(context: CommandExecutionContext): SModelRoot;
    protected shouldRemoveHandle(handle: SRoutingHandle, parent: Routable): boolean;
    undo(context: CommandExecutionContext): CommandResult;
    redo(context: CommandExecutionContext): CommandResult;
}
export interface HandleMove {
    elementId: string;
    fromPosition?: Point;
    toPosition: Point;
}
export interface ResolvedHandleMove {
    elementId: string;
    element: SRoutingHandle;
    parent: SParentElement;
    fromPosition?: Point;
    toPosition: Point;
}
export declare class MoveRoutingHandleAction implements Action {
    readonly moves: HandleMove[];
    readonly animate: boolean;
    kind: string;
    constructor(moves: HandleMove[], animate?: boolean);
}
export declare class MoveRoutingHandleCommand extends Command {
    protected action: MoveRoutingHandleAction;
    static KIND: string;
    resolvedMoves: Map<string, ResolvedHandleMove>;
    originalRoutingPoints: Map<string, Point[]>;
    constructor(action: MoveRoutingHandleAction);
    execute(context: CommandExecutionContext): CommandResult;
    protected resolve(move: HandleMove, index: SModelIndex<SModelElement>): ResolvedHandleMove | undefined;
    protected doMove(context: CommandExecutionContext): SModelRoot;
    undo(context: CommandExecutionContext): CommandResult;
    redo(context: CommandExecutionContext): CommandResult;
}
export declare class MoveHandlesAnimation extends Animation {
    protected model: SModelRoot;
    handleMoves: Map<string, ResolvedHandleMove>;
    originalRoutingPoints: Map<string, Point[]>;
    protected reverse: boolean;
    constructor(model: SModelRoot, handleMoves: Map<string, ResolvedHandleMove>, originalRoutingPoints: Map<string, Point[]>, context: CommandExecutionContext, reverse?: boolean);
    tween(t: number): SModelRoot;
}
//# sourceMappingURL=edit-routing.d.ts.map