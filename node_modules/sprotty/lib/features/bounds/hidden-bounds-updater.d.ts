import { VNode } from "snabbdom/vnode";
import { Bounds, Point } from '../../utils/geometry';
import { SModelElement, SModelRoot } from "../../base/model/smodel";
import { IVNodeDecorator } from "../../base/views/vnode-decorators";
import { IActionDispatcher } from "../../base/actions/action-dispatcher";
import { BoundsAware } from "./model";
import { Layouter } from "./layout";
export declare class BoundsData {
    vnode?: VNode;
    bounds?: Bounds;
    alignment?: Point;
    boundsChanged: boolean;
    alignmentChanged: boolean;
}
/**
 * Grabs the bounds from hidden SVG DOM elements, applies layouts and fires
 * ComputedBoundsActions.
 *
 * The actual bounds of an element can usually not be determined from the SModel
 * as they depend on the view implementation and CSS stylings. So the best way is
 * to grab them from a live (but hidden) SVG using getBBox().
 *
 * If an element is Alignable, and the top-left corner of its bounding box is not
 * the origin, we also issue a realign with the ComputedBoundsAction.
 */
export declare class HiddenBoundsUpdater implements IVNodeDecorator {
    protected actionDispatcher: IActionDispatcher;
    protected layouter: Layouter;
    constructor(actionDispatcher: IActionDispatcher, layouter: Layouter);
    private readonly element2boundsData;
    root: SModelRoot | undefined;
    decorate(vnode: VNode, element: SModelElement): VNode;
    postUpdate(): void;
    protected getBoundsFromDOM(): void;
    protected getBounds(elm: any, element: BoundsAware): Bounds;
}
//# sourceMappingURL=hidden-bounds-updater.d.ts.map