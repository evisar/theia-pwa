import { FluentIterable } from '../utils/iterable';
import { SChildElement, SModelElementSchema, SModelRootSchema, SModelIndex, SModelElement, SParentElement } from '../base/model/smodel';
import { Alignable, ModelLayoutOptions } from '../features/bounds/model';
import { Fadeable } from '../features/fade/model';
import { Hoverable } from '../features/hover/model';
import { Selectable } from '../features/select/model';
import { ViewportRootElement } from '../features/viewport/viewport-root';
import { Bounds, Point } from '../utils/geometry';
import { SShapeElement, SShapeElementSchema } from '../features/bounds/model';
import { Routable } from '../features/edit/model';
import { RoutedPoint, IEdgeRouter } from './routing';
/**
 * Serializable schema for graph-like models.
 */
export interface SGraphSchema extends SModelRootSchema {
    children: SModelElementSchema[];
    bounds?: Bounds;
    scroll?: Point;
    zoom?: number;
    layoutOptions?: ModelLayoutOptions;
}
/**
 * Root element for graph-like models.
 */
export declare class SGraph extends ViewportRootElement {
    layoutOptions?: ModelLayoutOptions;
    constructor(index?: SGraphIndex);
}
/**
 * A connectable element is one that can have outgoing and incoming edges, i.e. it can be the source
 * or target element of an edge. There are two kinds of connectable elements: nodes (`SNode`) and
 * ports (`SPort`). A node represents a main entity, while a port is a connection point inside a node.
 */
export declare abstract class SConnectableElement extends SShapeElement {
    /**
     * The incoming edges of this connectable element. They are resolved by the index, which must
     * be an `SGraphIndex`.
     */
    readonly incomingEdges: FluentIterable<SEdge>;
    /**
     * The outgoing edges of this connectable element. They are resolved by the index, which must
     * be an `SGraphIndex`.
     */
    readonly outgoingEdges: FluentIterable<SEdge>;
    /**
     * Compute an anchor position for routing an edge towards this element.
     *
     * The default implementation returns the element's center point. If edges should be connected
     * differently, e.g. to some point on the boundary of the element's view, the according computation
     * should be implemented in a subclass by overriding this method.
     *
     * @param referencePoint The point from which the edge is routed towards this element
     * @param offset An optional offset value to be considered in the anchor computation;
     *               positive values should shift the anchor away from this element, negative values
     *               should shift the anchor more to the inside.
     */
    getAnchor(referencePoint: Point, offset?: number): Point;
    /**
     * Compute an anchor position for routing an edge towards this element and correct any mismatch
     * of the coordinate systems.
     *
     * @param refPoint The point from which the edge is routed towards this element
     * @param refContainer The parent element that defines the coordinate system for `refPoint`
     * @param edge The edge for which the anchor is computed
     * @param offset An optional offset value (see `getAnchor`)
     */
    getTranslatedAnchor(refPoint: Point, refContainer: SParentElement, edge: SEdge, offset?: number): Point;
}
/**
 * Serializable schema for SNode.
 */
export interface SNodeSchema extends SShapeElementSchema {
    layout?: string;
    selected?: boolean;
    hoverFeedback?: boolean;
    opacity?: number;
}
/**
 * Model element class for nodes, which are the main entities in a graph. A node can be connected to
 * another node via an SEdge. Such a connection can be direct, i.e. the node is the source or target of
 * the edge, or indirect through a port, i.e. it contains an SPort which is the source or target of the edge.
 */
export declare class SNode extends SConnectableElement implements Selectable, Fadeable, Hoverable {
    children: SChildElement[];
    layout?: string;
    selected: boolean;
    hoverFeedback: boolean;
    opacity: number;
    hasFeature(feature: symbol): boolean;
}
/**
 * Serializable schema for SPort.
 */
export interface SPortSchema extends SShapeElementSchema {
    selected?: boolean;
    hoverFeedback?: boolean;
    opacity?: number;
}
/**
 * A port is a connection point for edges. It should always be contained in an SNode.
 */
export declare class SPort extends SConnectableElement implements Selectable, Fadeable, Hoverable {
    selected: boolean;
    hoverFeedback: boolean;
    opacity: number;
    hasFeature(feature: symbol): boolean;
}
/**
 * Serializable schema for SEdge.
 */
export interface SEdgeSchema extends SModelElementSchema {
    sourceId: string;
    targetId: string;
    routingPoints?: Point[];
    selected?: boolean;
    hoverFeedback?: boolean;
    opacity?: number;
}
/**
 * Model element class for edges, which are the connectors in a graph. An edge has a source and a target,
 * each of which can be either a node or a port. The source and target elements are referenced via their
 * ids and can be resolved with the index stored in the root element.
 */
export declare class SEdge extends SChildElement implements Fadeable, Selectable, Routable, Hoverable {
    sourceId: string;
    targetId: string;
    routingPoints: Point[];
    selected: boolean;
    hoverFeedback: boolean;
    opacity: number;
    sourceAnchorCorrection?: number;
    targetAnchorCorrection?: number;
    router?: IEdgeRouter;
    readonly source: SConnectableElement | undefined;
    readonly target: SConnectableElement | undefined;
    route(): RoutedPoint[];
    hasFeature(feature: symbol): boolean;
}
/**
 * Serializable schema for SLabel.
 */
export interface SLabelSchema extends SShapeElementSchema {
    text: string;
    selected?: boolean;
}
/**
 * A label can be attached to a node, edge, or port, and contains some text to be rendered in its view.
 */
export declare class SLabel extends SShapeElement implements Selectable, Alignable, Fadeable {
    text: string;
    selected: boolean;
    alignment: Point;
    opacity: number;
    hasFeature(feature: symbol): boolean;
}
/**
 * Serializable schema for SCompartment.
 */
export interface SCompartmentSchema extends SShapeElementSchema {
    layout?: string;
}
/**
 * A compartment is used to group multiple child elements such as labels of a node. Usually a `vbox`
 * or `hbox` layout is used to arrange these children.
 */
export declare class SCompartment extends SShapeElement implements Fadeable {
    children: SChildElement[];
    layout?: string;
    layoutOptions?: {
        [key: string]: string | number | boolean;
    };
    opacity: number;
    hasFeature(feature: symbol): boolean;
}
/**
 * A specialized model index that tracks outgoing and incoming edges.
 */
export declare class SGraphIndex extends SModelIndex<SModelElement> {
    private outgoing;
    private incoming;
    add(element: SModelElement): void;
    remove(element: SModelElement): void;
    getAttachedElements(element: SModelElement): FluentIterable<SModelElement>;
    getIncomingEdges(element: SConnectableElement): FluentIterable<SEdge>;
    getOutgoingEdges(element: SConnectableElement): FluentIterable<SEdge>;
}
//# sourceMappingURL=sgraph.d.ts.map