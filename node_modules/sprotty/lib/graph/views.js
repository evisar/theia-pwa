"use strict";
/*
 * Copyright (C) 2017 TypeFox and others.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/** @jsx svg */
var snabbdom_jsx_1 = require("snabbdom-jsx");
var geometry_1 = require("../utils/geometry");
var vnode_utils_1 = require("../base/views/vnode-utils");
var smodel_utils_1 = require("../base/model/smodel-utils");
var model_1 = require("../features/edit/model");
/**
 * IView component that turns an SGraph element and its children into a tree of virtual DOM elements.
 */
var SGraphView = /** @class */ (function () {
    function SGraphView() {
    }
    SGraphView.prototype.render = function (model, context) {
        var transform = "scale(" + model.zoom + ") translate(" + -model.scroll.x + "," + -model.scroll.y + ")";
        return snabbdom_jsx_1.svg("svg", { "class-sprotty-graph": true },
            snabbdom_jsx_1.svg("g", { transform: transform }, context.renderChildren(model)));
    };
    return SGraphView;
}());
exports.SGraphView = SGraphView;
var PolylineEdgeView = /** @class */ (function () {
    function PolylineEdgeView() {
    }
    PolylineEdgeView.prototype.render = function (edge, context) {
        var route = edge.route();
        if (route.length === 0)
            return this.renderDanglingEdge("Cannot compute route", edge, context);
        return snabbdom_jsx_1.svg("g", { "class-sprotty-edge": true, "class-mouseover": edge.hoverFeedback },
            this.renderLine(edge, route, context),
            this.renderAdditionals(edge, route, context),
            context.renderChildren(edge, { route: route }));
    };
    PolylineEdgeView.prototype.renderLine = function (edge, segments, context) {
        var firstPoint = segments[0];
        var path = "M " + firstPoint.x + "," + firstPoint.y;
        for (var i = 1; i < segments.length; i++) {
            var p = segments[i];
            path += " L " + p.x + "," + p.y;
        }
        return snabbdom_jsx_1.svg("path", { d: path });
    };
    PolylineEdgeView.prototype.renderAdditionals = function (edge, segments, context) {
        return [];
    };
    PolylineEdgeView.prototype.renderDanglingEdge = function (message, edge, context) {
        return snabbdom_jsx_1.svg("text", { "class-sprotty-edge-dangling": true, title: message }, "?");
    };
    return PolylineEdgeView;
}());
exports.PolylineEdgeView = PolylineEdgeView;
var SRoutingHandleView = /** @class */ (function () {
    function SRoutingHandleView() {
        this.minimalPointDistance = 10;
    }
    SRoutingHandleView.prototype.render = function (handle, context, args) {
        if (args && args.route) {
            var position = this.getPosition(handle, args.route);
            if (position !== undefined) {
                var node = snabbdom_jsx_1.svg("circle", { "class-sprotty-routing-handle": true, "class-selected": handle.selected, "class-mouseover": handle.hoverFeedback, cx: position.x, cy: position.y }); // Radius must be specified via CSS
                vnode_utils_1.setAttr(node, 'data-kind', handle.kind);
                return node;
            }
        }
        // Fallback: Create an empty group
        return snabbdom_jsx_1.svg("g", null);
    };
    SRoutingHandleView.prototype.getPosition = function (handle, route) {
        if (handle.kind === 'line') {
            return this.getLinePosition(handle, route);
        }
        else {
            return this.getJunctionPosition(handle, route);
        }
    };
    SRoutingHandleView.prototype.getJunctionPosition = function (handle, route) {
        return route.find(function (rp) { return rp.pointIndex === handle.pointIndex; });
    };
    SRoutingHandleView.prototype.getLinePosition = function (handle, route) {
        var parent = handle.parent;
        if (model_1.isRoutable(parent)) {
            var getIndex = function (rp) {
                if (rp.pointIndex !== undefined)
                    return rp.pointIndex;
                else if (rp.kind === 'target')
                    return parent.routingPoints.length;
                else
                    return -1;
            };
            var rp1 = void 0, rp2 = void 0;
            for (var _i = 0, route_1 = route; _i < route_1.length; _i++) {
                var rp = route_1[_i];
                var i = getIndex(rp);
                if (i <= handle.pointIndex && (rp1 === undefined || i > getIndex(rp1)))
                    rp1 = rp;
                if (i > handle.pointIndex && (rp2 === undefined || i < getIndex(rp2)))
                    rp2 = rp;
            }
            if (rp1 !== undefined && rp2 !== undefined) {
                // Skip this handle if its related line segment is not included in the route
                if (getIndex(rp1) !== handle.pointIndex && handle.pointIndex >= 0) {
                    var point = parent.routingPoints[handle.pointIndex];
                    if (geometry_1.maxDistance(point, rp1) >= geometry_1.maxDistance(point, rp2))
                        return undefined;
                }
                if (getIndex(rp2) !== handle.pointIndex + 1 && handle.pointIndex + 1 < parent.routingPoints.length) {
                    var point = parent.routingPoints[handle.pointIndex + 1];
                    if (geometry_1.maxDistance(point, rp1) < geometry_1.maxDistance(point, rp2))
                        return undefined;
                }
                // Skip this handle if its related line segment is too short
                if (geometry_1.maxDistance(rp1, rp2) >= this.minimalPointDistance)
                    return geometry_1.centerOfLine(rp1, rp2);
            }
        }
        return undefined;
    };
    return SRoutingHandleView;
}());
exports.SRoutingHandleView = SRoutingHandleView;
var SLabelView = /** @class */ (function () {
    function SLabelView() {
    }
    SLabelView.prototype.render = function (label, context) {
        var vnode = snabbdom_jsx_1.svg("text", { "class-sprotty-label": true }, label.text);
        var subType = smodel_utils_1.getSubType(label);
        if (subType)
            vnode_utils_1.setAttr(vnode, 'class', subType);
        return vnode;
    };
    return SLabelView;
}());
exports.SLabelView = SLabelView;
var SCompartmentView = /** @class */ (function () {
    function SCompartmentView() {
    }
    SCompartmentView.prototype.render = function (model, context) {
        var translate = "translate(" + model.bounds.x + ", " + model.bounds.y + ")";
        var vnode = snabbdom_jsx_1.svg("g", { transform: translate, "class-sprotty-comp": "{true}" }, context.renderChildren(model));
        var subType = smodel_utils_1.getSubType(model);
        if (subType)
            vnode_utils_1.setAttr(vnode, 'class', subType);
        return vnode;
    };
    return SCompartmentView;
}());
exports.SCompartmentView = SCompartmentView;
//# sourceMappingURL=views.js.map