import { SModelRoot } from "../model/smodel";
import { AnimationFrameSyncer } from "../animations/animation-frame-syncer";
import { IViewer } from "./viewer";
/**
 * Updating the view is rather expensive, and it doesn't make sense to calculate
 * more then one update per animation (rendering) frame. So this class batches
 * all incoming model changes and only renders the last one when the next animation
 * frame comes.
 */
export declare class ViewerCache implements IViewer {
    protected delegate: IViewer;
    protected syncer: AnimationFrameSyncer;
    constructor(delegate: IViewer, syncer: AnimationFrameSyncer);
    cachedModelRoot: SModelRoot | undefined;
    cachedHiddenModelRoot: SModelRoot | undefined;
    cachedPopup: SModelRoot | undefined;
    protected isCacheEmpty(): boolean;
    updatePopup(model: SModelRoot): void;
    update(model: SModelRoot): void;
    updateHidden(hiddenModel: SModelRoot): void;
    protected scheduleUpdate(): void;
}
//# sourceMappingURL=viewer-cache.d.ts.map