import { ILogger } from "../../utils/logging";
import { IModelFactory } from "../model/smodel-factory";
import { SModelRoot } from "../model/smodel";
import { AnimationFrameSyncer } from "../animations/animation-frame-syncer";
import { IViewer, IViewerProvider } from "../views/viewer";
import { CommandStackOptions } from './command-stack-options';
import { ICommand, CommandExecutionContext, CommandResult, SystemCommand } from './command';
/**
 * The component that holds the current model and applies the commands
 * to change it.
 *
 * The command stack is called by the ActionDispatcher and forwards the
 * changed model to the Viewer that renders it.
 */
export interface ICommandStack {
    /**
     * Executes the given command on the current model and returns a
     * Promise for the new result.
     *
     * Unless it is a special command, it is pushed to the undo stack
     * such that it can be rolled back later and the redo stack is
     * cleared.
     */
    execute(command: ICommand): Promise<SModelRoot>;
    /**
     * Executes all of the given commands. As opposed to calling
     * execute() multiple times, the Viewer is only updated once after
     * the last command has been executed.
     */
    executeAll(commands: ICommand[]): Promise<SModelRoot>;
    /**
     * Takes the topmost command from the undo stack, undoes its
     * changes and pushes it ot the redo stack. Returns a Promise for
     * the changed model.
     */
    undo(): Promise<SModelRoot>;
    /**
     * Takes the topmost command from the redo stack, redoes its
     * changes and pushes it ot the undo stack. Returns a Promise for
     * the changed model.
     */
    redo(): Promise<SModelRoot>;
}
/**
 * As part of the event cylce, the ICommandStack should be injected
 * using a provider to avoid cyclic injection dependencies.
 */
export declare type CommandStackProvider = () => Promise<ICommandStack>;
/**
 * The implementation of the ICommandStack. Clients should not use this
 * class directly.
 *
 * The command stack holds the current model as the result of the current
 * promise. When a new command is executed/undone/redone, its execution is
 * chained using <code>Promise#then()</code> to the current Promise. This
 * way we can handle long running commands without blocking the current
 * thread.
 *
 * The command stack also does the special handling for special commands:
 *
 * System commands should be transparent to the user and as such be
 * automatically undone/redone with the next plain command. Additional care
 * must be taken that system commands that are executed after undo don't
 * break the correspondence between the topmost commands on the undo and
 * redo stacks.
 *
 * Hidden commands only tell the viewer to render a hidden model such that
 * its bounds can be extracted from the DOM and forwarded as separate actions.
 * Hidden commands should not leave any trace on the undo/redo/off stacks.
 *
 * Mergeable commands should be merged with their predecessor if possible,
 * such that e.g. multiple subsequent moves of the smae element can be undone
 * in one single step.
 */
export declare class CommandStack implements ICommandStack {
    protected modelFactory: IModelFactory;
    protected viewerProvider: IViewerProvider;
    protected logger: ILogger;
    protected syncer: AnimationFrameSyncer;
    protected options: CommandStackOptions;
    protected currentPromise: Promise<CommandStackState>;
    protected viewer?: IViewer;
    protected undoStack: ICommand[];
    protected redoStack: ICommand[];
    /**
     * System commands should be transparent to the user in undo/redo
     * operations. When a system command is executed when the redo
     * stack is not empty, it is pushed to offStack instead.
     *
     * On redo, all commands form this stack are undone such that the
     * redo operation gets the exact same model as when it was executed
     * first.
     *
     * On undo, all commands form this stack are undone as well as
     * system ommands should be transparent to the user.
     */
    protected offStack: SystemCommand[];
    constructor(modelFactory: IModelFactory, viewerProvider: IViewerProvider, logger: ILogger, syncer: AnimationFrameSyncer, options: CommandStackOptions);
    protected readonly currentModel: Promise<SModelRoot>;
    executeAll(commands: ICommand[]): Promise<SModelRoot>;
    execute(command: ICommand): Promise<SModelRoot>;
    undo(): Promise<SModelRoot>;
    redo(): Promise<SModelRoot>;
    /**
     * Chains the current promise with another Promise that performs the
     * given operation on the given command.
     *
     * @param beforeResolve a function that is called directly before
     * resolving the Promise to return the new model. Usually puts the
     * command on the appropriate stack.
     */
    protected handleCommand(command: ICommand, operation: (context: CommandExecutionContext) => CommandResult, beforeResolve: (command: ICommand, context: CommandExecutionContext) => void): void;
    protected pushToUndoStack(command: ICommand): void;
    /**
     * Notifies the Viewer to render the new model and/or the new hidden model
     * and returns a Promise for the new model.
     */
    protected thenUpdate(): Promise<SModelRoot>;
    /**
     * Notify the <code>Viewer</code> that the model has changed.
     */
    update(model: SModelRoot): Promise<void>;
    /**
     * Notify the <code>Viewer</code> that the hidden model has changed.
     */
    updateHidden(model: SModelRoot): Promise<void>;
    /**
     * Notify the <code>Viewer</code> that the model has changed.
     */
    updatePopup(model: SModelRoot): Promise<void>;
    /**
     * Handling of commands after their execution.
     *
     * Hidden commands are not pushed to any stack.
     *
     * System commands are pushed to the <code>offStack</code> when the redo
     * stack is not empty, allowing to undo the before a redo to keep the chain
     * of commands consistent.
     *
     * Mergable commands are merged if possible.
     */
    protected mergeOrPush(command: ICommand, context: CommandExecutionContext): void;
    /**
     * Reverts all system commands on the offStack.
     */
    protected undoOffStackSystemCommands(): void;
    /**
     * System commands should be transparent to the user, so this method
     * is called from <code>undo()</code> to revert all system commands
     * at the top of the undoStack.
     */
    protected undoPreceedingSystemCommands(): void;
    /**
     * System commands should be transparent to the user, so this method
     * is called from <code>redo()</code> to re-execute all system commands
     * at the top of the redoStack.
     */
    protected redoFollowingSystemCommands(): void;
    /**
     * Assembles the context object that is passed to the commands execution method.
     */
    protected createContext(currentModel: SModelRoot): CommandExecutionContext;
}
/**
 * Internal type to pass the results between the <code>Promises</code> in the
 * <code>ICommandStack</code>.
 */
export interface CommandStackState {
    root: SModelRoot;
    hiddenRoot: SModelRoot | undefined;
    popupRoot: SModelRoot | undefined;
    rootChanged: boolean;
    hiddenRootChanged: boolean;
    popupChanged: boolean;
}
//# sourceMappingURL=command-stack.d.ts.map